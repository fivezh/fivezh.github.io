<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小武的博客</title>
  <icon>https://www.gravatar.com/avatar/4f961b8cd32630b3280ef1fbe98d7070</icon>
  <subtitle>记录、分享、成长</subtitle>
  <link href="http://fivezh.github.io/atom.xml" rel="self"/>
  
  <link href="http://fivezh.github.io/"/>
  <updated>2022-11-08T02:54:47.832Z</updated>
  <id>http://fivezh.github.io/</id>
  
  <author>
    <name>小武</name>
    <email>fivezh@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[基础库] path包使用</title>
    <link href="http://fivezh.github.io/2022/11/07/daily-go-pkg-path/"/>
    <id>http://fivezh.github.io/2022/11/07/daily-go-pkg-path/</id>
    <published>2022-11-07T14:04:00.000Z</published>
    <updated>2022-11-08T02:54:47.832Z</updated>
    
    <content type="html"><![CDATA[<p><code>Go</code>标准库中自带<code>path包</code>使用说明：</p><blockquote><p>Package path implements utility routines for manipulating slash-separated paths.<br>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.<br><a id="more"></a></p></blockquote><blockquote><p>包路径实现了用于操作斜杠分隔路径的实用程序。<br>path 包只能用于由正斜杠分隔的路径，例如 URL 中的路径。 此软件包不处理带有驱动器号或反斜杠的 Windows 路径； 要操作操作系统路径，请使用 path/filepath 包。<br><a href="https://pkg.go.dev/path" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><ul><li><code>path</code>包包含了以<code>/</code>分割的路径处理操作</li><li>将路径字符串以<code>/</code>分割后，按每个元素来处理</li><li><code>dir</code>是目录，输出时会剔除尾部的<code>/</code></li><li><code>.</code>、<code>..</code>、<code>/</code>均为特殊处理case</li></ul><p>函数列表：</p><ul><li>func Base(path string) string: 返回路径中的最后一个元素</li><li>func Clean(path string) string: 标准化path处理</li><li>func Dir(path string) string: 获取路径的目录</li><li>func Ext(path string) string: 获取路径的文件名后缀</li><li>func IsAbs(path string) bool: 是否绝对路径</li><li>func Join(elem …string) string：路径拼接</li><li>func Match(pattern, name string) (matched bool, err error)：路径<code>name</code>是否匹配shell格式的<code>pattern</code></li><li>func Split(path string) (dir, file string): 将全路径分割为目录和文件名</li></ul><h2 id="func-Base-path-string-string"><a href="#func-Base-path-string-string" class="headerlink" title="func Base(path string) string"></a><code>func Base(path string) string</code></h2><p>函数说明：</p><ul><li><code>Base</code>返回路径中的最后一个元素</li><li>将路径<code>path</code>按<code>/</code>拆分后，最后一个元素为<code>basename</code></li><li>和Linux中命令<code>basename</code>操作一致</li></ul><p>注意事项：</p><ul><li>空字符串时返回’.’</li><li>全斜线(一个或多个)的字符串返回’/‘</li><li>结尾的<code>/</code>将会被移除，也就是说<code>Base{&quot;/home/&quot;}</code>和<code>Base{&quot;/home&quot;}</code>返回结果一样，都是<code>&quot;home&quot;</code></li></ul><h2 id="func-Clean-path-string-string"><a href="#func-Clean-path-string-string" class="headerlink" title="func Clean(path string) string"></a><code>func Clean(path string) string</code></h2><p>函数说明：<br>作用：路径标准化处理，返回等价的最短路径</p><ul><li>多个连续<code>/</code>合并为单个</li><li>消除当前目录的<code>.</code>标识</li><li>消除<code>..</code>路径元素和它之前的<code>非..</code>元素</li><li>将根路径下的<code>/..</code>替换为<code>/</code></li><li>只有当路径为<code>/</code>时返回路径才会以<code>/</code>结尾</li><li>空路径处理后返回<code>.</code></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理效果，可执行源码参见[path#example-Clean](https://pkg.go.dev/path#example-Clean)</span></span><br><span class="line">Clean(<span class="string">"a/c"</span>) = <span class="string">"a/c"</span></span><br><span class="line">Clean(<span class="string">"a//c"</span>) = <span class="string">"a/c"</span></span><br><span class="line">Clean(<span class="string">"a/c/."</span>) = <span class="string">"a/c"</span></span><br><span class="line">Clean(<span class="string">"a/c/b/.."</span>) = <span class="string">"a/c"</span></span><br><span class="line">Clean(<span class="string">"/../a/c"</span>) = <span class="string">"/a/c"</span></span><br><span class="line">Clean(<span class="string">"/../a/b/../././/c"</span>) = <span class="string">"/a/c"</span></span><br><span class="line">Clean(<span class="string">""</span>) = <span class="string">"."</span></span><br></pre></td></tr></table></figure><h2 id="func-Dir-path-string-string"><a href="#func-Dir-path-string-string" class="headerlink" title="func Dir(path string) string"></a><code>func Dir(path string) string</code></h2><p>作用：获取路径中的目录</p><ul><li>返回路径中除最后一个元素外的路径，通常未path指向的目录</li><li>通过Split分割路径，剔除最后一个元素和结尾的<code>/</code></li><li>路径为空，则返回<code>.</code></li><li>除下述情况返回以<code>/</code>结尾外，其他情况均不会返回以<code>/</code>结尾<ul><li>path为多个连续<code>/</code>，后跟<code>非/</code>元素，入<code>////foo</code>将返回<code>/</code></li></ul></li></ul><h2 id="func-Ext-path-string-string"><a href="#func-Ext-path-string-string" class="headerlink" title="func Ext(path string) string"></a><code>func Ext(path string) string</code></h2><p>作用：获取路径中的文件扩展名</p><ul><li>获取路径中的文件扩展名</li><li>扩展名是<code>/</code>分割的最后一个元素中，以最末尾的<code>.</code>开始的后缀部分</li><li>如果最后一个元素没有<code>.</code>，则返回空</li></ul><h2 id="func-IsAbs-path-string-bool"><a href="#func-IsAbs-path-string-bool" class="headerlink" title="func IsAbs(path string) bool"></a><code>func IsAbs(path string) bool</code></h2><p>作用：判断输出path是否为绝对路径</p><p>绝对路径：只有以<code>/</code>开始的全路径才是绝对路径</p><h2 id="func-Join-elem-string-string"><a href="#func-Join-elem-string-string" class="headerlink" title="func Join(elem ...string) string"></a><code>func Join(elem ...string) string</code></h2><p>作用：路径拼接</p><ul><li>使用<code>/</code>拼接多个元素为路径</li><li>空元素将被忽略</li><li>返回结果会调用<code>Clean()</code>标准化处理</li><li>如果多个入参均为空字符串，则返回结果也为空字符串</li></ul><h2 id="func-Match-pattern-name-string-matched-bool-err-error"><a href="#func-Match-pattern-name-string-matched-bool-err-error" class="headerlink" title="func Match(pattern, name string) (matched bool, err error)"></a><code>func Match(pattern, name string) (matched bool, err error)</code></h2><p>作用：路径<code>name</code>是否匹配shell格式的<code>pattern</code></p><h2 id="func-Split-path-string-dir-file-string"><a href="#func-Split-path-string-dir-file-string" class="headerlink" title="func Split(path string) (dir, file string)"></a><code>func Split(path string) (dir, file string)</code></h2><p>作用：将全路径分割为目录和文件名</p><ul><li>按最后一个<code>/</code>进行路径分割，分割为目录和文件名两部分</li><li>如果路径中没有<code>/</code>，则返回目录为空、文件名=path</li><li><code>path = dir + file</code></li></ul><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><ul><li><a href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter06/06.2.html" target="_blank" rel="noopener">《Go语言标准库》6.2 path/filepath</a></li><li><a href="https://pkg.go.dev/path" target="_blank" rel="noopener">pkg.go.dev/path</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;标准库中自带&lt;code&gt;path包&lt;/code&gt;使用说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Package path implements utility routines for manipulating slash-separated paths.&lt;br&gt;The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.&lt;br&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GoLang 中 Json Tag用法汇总</title>
    <link href="http://fivezh.github.io/2022/02/01/golang-json-tag/"/>
    <id>http://fivezh.github.io/2022/02/01/golang-json-tag/</id>
    <published>2022-02-01T07:42:43.000Z</published>
    <updated>2022-02-06T14:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>GoLang中结构体的 <code>JSON Tag</code> 标识（英文名backquote或backtick，反引号 ` 符号包裹的部分内容）一直未明确看过完整规范和使用说明，存在模棱两可，系统整理如下：</p><ul><li><code>JSON Tag</code>标签的完整语法，包含哪些选项</li><li>不同选项（输出名/-/omitempty/string）的作用及使用范围</li><li>特殊注意事项补充</li></ul><a id="more"></a><h2 id="Json中Tag用法汇总"><a href="#Json中Tag用法汇总" class="headerlink" title="Json中Tag用法汇总"></a>Json中Tag用法汇总</h2><ul><li>JSON Tag标签格式为：<code>json:&quot;FieldName/-/可选,omitempty/可选,string/可选</code></li><li>多个选项之间使用 <code>,</code> 逗号分割</li><li><code>FieldName</code>选项：指定编码后键名称<ul><li>可为空，则使用Struct对应字段名作为JSON输出名</li><li><code>FieldName</code>非空，则使用指定的FieldName作为JSON输出名</li><li><code>-</code>符号，输出时忽略此字段；但要注意<code>-,</code>（多一个逗号结尾）时，输出字段名为<code>-</code>的JSON字段，而不是忽略</li></ul></li><li><code>omitempty</code>选项：忽略空值<ul><li>包含此选项，输出时字段空值（零值+空值：false、0、nil指针、nil接口值，以及任何空数组、切片、map或字符串）则不输出</li></ul></li><li><code>string</code>选项：结果输出为字符串<ul><li>字段结果输出为<code>字符串</code></li><li>只适用于字符串、浮点、整数或布尔类型的字段</li><li>这种额外的编码有时在与 JavaScript 程序通信时使用</li><li>要注意，如果字段值本身为<code>string</code>时，再次增加JSON的<code>string</code>标签选项，会导致多个引号的情况</li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码：https://go.dev/play/p/ApzFQttV_MB</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Hello   <span class="keyword">bool</span>     <span class="string">`json:"Hello,string"`</span></span><br><span class="line">world   <span class="keyword">bool</span>     <span class="string">`json:"World,string"`</span></span><br><span class="line">ID      <span class="keyword">int</span>      <span class="string">`json:"id,string"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`json:"name,string"`</span></span><br><span class="line">Colors  []<span class="keyword">string</span> <span class="string">`json:"ColorName,omitempty"`</span></span><br><span class="line">Colors1 []<span class="keyword">string</span> <span class="string">`json:"ColorName1"`</span></span><br><span class="line">Colors2 []<span class="keyword">string</span> <span class="string">`json:"ColorName2"`</span></span><br><span class="line">&#125;</span><br><span class="line">group := ColorGroup&#123;</span><br><span class="line">Hello:   <span class="literal">true</span>,</span><br><span class="line">world:   <span class="literal">true</span>,</span><br><span class="line">ID:      <span class="number">1</span>,</span><br><span class="line">Name:    <span class="string">"Reds"</span>,</span><br><span class="line">Colors:  []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;,</span><br><span class="line">Colors1: <span class="literal">nil</span>,</span><br><span class="line">Colors2: []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(group)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">//&#123;"Hello":"true","id":"1","name":"\"Reds\"","ColorName":["hello","world"],"ColorName1":null,"ColorName2":[]&#125;</span></span><br></pre></td></tr></table></figure><p>其他注意：</p><ul><li><code>nil</code> 指针、<code>nil</code> 接口、<code>nil</code>切片等nil类型值，进行编码后为 <code>null</code> JSON 对象</li><li>空切片、空数组编码为 <code>[]</code> JSON 数组</li><li><code>map</code> 编码为 <code>{}</code> JSON 对象</li><li>指针类型值编码为指针所指向的值，接口类型值编码后为对应类型的值</li></ul><h2 id="官方-Marshal-函数说明"><a href="#官方-Marshal-函数说明" class="headerlink" title="官方 Marshal 函数说明"></a>官方 <code>Marshal</code> 函数说明</h2><p><code>func Marshal(v interface{}) ([]byte, error)</code></p><p><code>Marshal</code> 返回变量 <code>v</code> 的 <code>JSON</code> 编码后结果<br><code>Marshal</code> 函数会递归的处理变量 <code>v</code>；如果一个值实现了<code>Marshaler</code>接口，并且不是一个<code>nil</code>指针，<code>Marshal</code> 调用其 <code>MarshalJSON</code> 方法来生成 JSON 数据。如果没有 <code>MarshalJSON</code> 方法但实现了 <code>encoding.TextMarshaler</code> 方法，<code>Marshal</code> 调用 <code>MarshalText</code> 方法并将结果编码为 JSON 字符串。<code>nil</code> 指针异常并不是严格意义上的必须，而是模仿了UnmarshalJSON行为中的一个类似的、必须的异常。</p><p>否则，Marshal使用以下与类型有关的默认编码：</p><ul><li>布尔值被编码为JSON布尔值</li><li>浮点、整数和数值类型值编码为JSON数字</li><li>字符串值被编码为JSON字符串，被强制为有效的UTF-8，用Unicode替换符文替换无效的字节。为了使JSON能够安全地嵌入到HTML <code>&lt;script&gt;</code>标签中，字符串使用HTMLEscape进行编码，将”&lt;”、”&gt;”、”&amp;”、”U+2028”和”U+2029”转义为”\u003c”、”\u003e”、”\u0026”、”\u2028”、和”\u2029”。在使用编码器时，可以通过调用SetEscapeHTML(false)禁用这种替换。</li><li>数组和分片的值会被编码为JSON数组，但<code>[]byte</code>会被编码为base64编码的字符串，而nil切片会被编码为null JSON对象值。<ul><li>数组、分片，编码后为 JSON 数组</li><li><code>[]byte</code>空切片，编码后为空数组 <code>[]</code></li><li>nil 切片，编码后为 <code>null</code></li></ul></li><li>结构体类型的值被编码为JSON对象。每个导出的结构字段都会成为对象的成员，使用字段名作为对象的键，除非字段因为下面的原因被省略<ul><li>每个结构字段的编码都可通过存储在结构字段Tag标签的 “json” 键下的<code>格式字符串</code>来定制。格式字符串给出了字段的名称，后面可能有一个用逗号分隔的选项列表。名称可以是空的，以便指定选项而不覆盖默认的字段名</li><li>“omitempty”选项，如果字段为空值，应该从编码中省略，定义为false、0、nil指针、nil接口值，以及任何空数组、切片、map或字符串</li><li>作为一种特殊情况，如果字段标签是”-“，字段总是被省略的。请注意，一个名称为”-“的字段仍然可以使用标签”-,”来生成</li></ul></li></ul><p>结构体字段Tag标签下 <code>json</code> 键对应格式化字符串说明：</p><ul><li>给出字段编码后的名称，后面可能有一组逗号分割的选项列表</li><li>字段名称可以为空，用于在不覆盖默认字段名的情况下指定不同选项</li><li><code>omitempty</code>选项，字段为空值（false/0/nil指针/nil接口值/空数组/空切片/空map/空字符串）时则跳过编码输出</li><li>字段标签为<code>-</code>时，此字段总是被忽略；但要注意，名为<code>-</code>的字段出现在<code>-,</code>标签中时仍可以被生成</li></ul><p>结构体字段标签和对应含义的一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field appears in JSON as key "myName".</span></span><br><span class="line"><span class="comment">// 该字段出现在JSON中时，名为"myName"</span></span><br><span class="line">Field <span class="keyword">int</span> <span class="string">`json:"myName"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key "myName" and</span></span><br><span class="line"><span class="comment">// the field is omitted from the object if its value is empty,</span></span><br><span class="line"><span class="comment">// as defined above.</span></span><br><span class="line"><span class="comment">// 该字段出现在JSON中时，名为"myName"，如为零值则输出时忽略此字段</span></span><br><span class="line">Field <span class="keyword">int</span> <span class="string">`json:"myName,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key "Field" (the default), but</span></span><br><span class="line"><span class="comment">// the field is skipped if empty.</span></span><br><span class="line"><span class="comment">// Note the leading comma.</span></span><br><span class="line"><span class="comment">// 该字段出现在JSON中时，名为"Field"，如为零值则输出时忽略此字段</span></span><br><span class="line">Field <span class="keyword">int</span> <span class="string">`json:",omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field is ignored by this package.</span></span><br><span class="line"><span class="comment">// 该字段当前包输出JSON时忽略</span></span><br><span class="line">Field <span class="keyword">int</span> <span class="string">`json:"-"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key "-".</span></span><br><span class="line"><span class="comment">// 该字段出现在JSON中时，名为"-"</span></span><br><span class="line">Field <span class="keyword">int</span> <span class="string">`json:"-,"`</span></span><br></pre></td></tr></table></figure><p><code>&quot;string&quot;</code> 选项表示字段以 JSON 格式存储在 JSON 编码的字符串中。它只适用于字符串、浮点、整数或布尔类型的字段。这种额外的编码有时在与JavaScript程序通信时使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int64String <span class="keyword">int64</span> <span class="string">`json:",string"`</span></span><br></pre></td></tr></table></figure><p>键名满足以下条件时将被使用：非空字符串，仅由Unicode字母、数字和ASCII标点符号（不包括引号、反斜杠和逗号）组成。<br>受下文所述的Go可见性规则的限制，匿名结构字段通常可被编码，其内部可导出的字段等价于外部结构中的字段。匿名结构体字段使用其JSON Tag标签中给出名称，而不是匿名的。接口类型的匿名结构字段的处理方式与将该类型作为其名称相同，也不是匿名。<br>在决定对哪个字段进行marshal或unmarshal时，Go中结构体字段可见性规则进行了调整。如果在同一级别有多个字段，并且该级别是嵌套最少的（且将是通常Go规则所选择的嵌套级别），则适用以下额外规则：</p><p>1) 在这些字段中，如果有任何字段是JSON Tag标记的，就只考虑有标记的字段，即使有多个未标记的字段，否则会发生冲突。</p><p>2) 如果只有一个字段（根据第一条规则标记或不标记），该字段被选中。</p><p>3) 否则有多个字段，都会被忽略；不会发生错误。</p><p>Go 1.1中新增了对匿名结构字段的处理。在Go 1.1之前，匿名结构字段被忽略。要在当前版本和早期版本中强制忽略匿名结构字段，请给该字段一个”-“的JSON标签。</p><p><code>Map</code>的值被编码为JSON对象。地图的键类型必须是字符串、整数类型，或者实现了<code>encoding.TextMarshaler</code>接口。通过应用以下规则对<code>Map</code>的键进行排序并作为JSON对象的键使用，但要遵守上面为字符串值描述的UTF-8强制规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 任何字符串类型的键都可以直接使用</span><br><span class="line">- encoding.TextMarshalers 将被编码</span><br><span class="line">- 整数键被转换为字符串</span><br></pre></td></tr></table></figure><p>指针类型值被编码为所指向的值，一个 <code>nil</code> 指针会被编码为 <code>null</code> JSON值。<br>接口类型值编码为接口中包含的值，一个 <code>nil</code> 接口值被编码为 <code>null</code> JSON值。<br>通道（Channel）、复合类型（complex）和函数值（function）不能进行JSON编码，试图对这样的值进行编码会导致Marshal返回一个<code>UnsupportedTypeError</code>错误。<br>JSON不能代表循环嵌套的数据结构，Marshal函数也将不处理它们。向Marshal传递循环结构将导致一个错误。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pkg.go.dev/encoding/json#Marshal" target="_blank" rel="noopener">encoding/json#Marshal</a></li><li><a href="https://blog.csdn.net/xz_studying/article/details/106012535" target="_blank" rel="noopener">struct json tag的使用及深入理解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;GoLang中结构体的 &lt;code&gt;JSON Tag&lt;/code&gt; 标识（英文名backquote或backtick，反引号 ` 符号包裹的部分内容）一直未明确看过完整规范和使用说明，存在模棱两可，系统整理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JSON Tag&lt;/code&gt;标签的完整语法，包含哪些选项&lt;/li&gt;
&lt;li&gt;不同选项（输出名/-/omitempty/string）的作用及使用范围&lt;/li&gt;
&lt;li&gt;特殊注意事项补充&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>VsCode中 Go 编程推荐好用的扩展</title>
    <link href="http://fivezh.github.io/2022/01/08/vscode-extenions/"/>
    <id>http://fivezh.github.io/2022/01/08/vscode-extenions/</id>
    <published>2022-01-08T13:24:23.000Z</published>
    <updated>2025-07-09T02:43:11.867Z</updated>
    
    <content type="html"><![CDATA[<p>近来主要使用<code>Visual Studio Code</code>进行Go编程，以下是我认为好用的扩展，分享记录下来。<br><a id="more"></a></p><h2 id="1-Code-Runner"><a href="#1-Code-Runner" class="headerlink" title="1. Code Runner"></a>1. Code Runner</h2><p>快速运行代码，支持多种语言，不局限于Go。</p><h2 id="2-Go"><a href="#2-Go" class="headerlink" title="2. Go"></a>2. Go</h2><p>不多说了，Go语言开发必备。</p><h2 id="3-Go-Mod-Explorer"><a href="#3-Go-Mod-Explorer" class="headerlink" title="3. Go Mod Explorer"></a>3. Go Mod Explorer</h2><p><code>Go Mod Explorer</code> 是一个用于管理 Go 模块的扩展，它可以帮助你查看依赖 Go 模块整体源码，类似于<code>GoLand</code>中的<code>External Libraries</code>功能。</p><p><img src="/assets/post_images/gomod-explorer.png" alt="gomod-explorer"></p><ul><li>跳转源码后，在<code>GOMOD Explorer</code>中，可以查看依赖模块的源码结构，默认选中当前打开的源码文件。</li><li>文件夹上右侧图标可以在源码目录下检索文件。</li><li>上述这两个是之前无法割舍<code>GoLand</code>的最大痛点，有了这两个扩展，<code>GoLand</code>几乎可以丢掉了。<ul><li>对于源码学习而言，全局结构、快速检索文件，<code>Go Mod Explorer</code>已经可以很好满足。</li></ul></li></ul><h2 id="其他记录"><a href="#其他记录" class="headerlink" title="其他记录"></a>其他记录</h2><ul><li>Go struct tag：结构体标签代码生成功能</li><li>JSON To Go：JSON 字符串转Go结构体代码</li><li>Bookmarks：书签管理，方便跳转收藏的任意文件/行</li><li>Code Spell Check：代码拼写检查</li><li><code>Go Extension Pack</code>：这个是网友整理的汇总版，我没用，按需取用</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;近来主要使用&lt;code&gt;Visual Studio Code&lt;/code&gt;进行Go编程，以下是我认为好用的扩展，分享记录下来。&lt;br&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[译] Clickhouse 在日志存储与分析方面替代 ElasticSearch 和 MySQL</title>
    <link href="http://fivezh.github.io/2021/03/14/2021-clickhouse/"/>
    <id>http://fivezh.github.io/2021/03/14/2021-clickhouse/</id>
    <published>2021-03-14T12:00:03.000Z</published>
    <updated>2021-03-14T15:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文地址：<a href="https://pixeljets.com/blog/clickhouse-vs-elasticsearch/" target="_blank" rel="noopener">https://pixeljets.com/blog/clickhouse-vs-elasticsearch/</a></li><li>原文作者：Anton Sidashin</li><li>本文永久链接：<a href="https://github.com/gocn/translator/blob/master/2021/w10_Clickhouse_for_log_storage_and_analysis_in_2021.md" target="_blank" rel="noopener">https://github.com/gocn/translator/blob/master/2021/w10_Clickhouse_for_log_storage_and_analysis_in_2021.md</a></li><li>译者：<a href="https://github.com/fivezh" target="_blank" rel="noopener">Fivezh</a></li><li>校对：<a href="https://github.com/watermelo" target="_blank" rel="noopener">咔叽咔叽</a><a id="more"></a></li></ul><p>2018年，我写过一篇<a href="https://pixeljets.com/blog/clickhouse-as-a-replacement-for-elk-big-query-and-timescaledb/" target="_blank" rel="noopener">关于Clickhouse的文章</a>，这段内容在互联网上仍然很流行，甚至被多次翻译。现在已经过去两年多，同时 Clickhouse 的开发节奏<a href="https://github.com/ClickHouse/ClickHouse/pulse/monthly" target="_blank" rel="noopener">仍然活跃</a>: 上个月有 800 个合并的 PR ! 这难道没让你大吃一惊吗？或许需要一小时才能查看完这些变更日志和新功能描述，例如 2020 年：<a href="https://clickhouse.tech/docs/en/whats-new/changelog/2020/" target="_blank" rel="noopener">https://clickhouse.tech/docs/en/whats-new/changelog/2020/</a></p><blockquote><p>为了公平对比，<a href="https://github.com/elastic/elasticsearch/pulse/monthly" target="_blank" rel="noopener"> ElasticSearch 仓库在同一个月有惊人的 1076 个合并 PR </a>，同时在功能性方面，它的节奏也<em>非常</em>让人印象深刻！</p></blockquote><p>我们正在将 Clickhouse 用于 <a href="https://apiroad.net/" target="_blank" rel="noopener">ApiRoad.net</a> 项目（这是一个 API 市场，开发人员出售其 API ，目前活跃开发中）的日志存储和分析，到目前为止，我们对效果感到满意。作为一名 API 开发人员， HTTP 请求/响应周期的可观察性和可分析性对于维护服务质量和快速发现 bug 非常重要，这一点对于纯 API 服务尤其如此。</p><p><img src="https://pixeljets.com/blog/content/images/2021/02/demo2--1-.gif" alt="img"></p><p>我们也在其他项目上使用 ELK（ ElasticSearch，Logstash，filebeat，Kibana）技术栈用于同样目的：获取 HTTP 和邮件日志，使用 Kibana 进行事后的分析与搜索。</p><p>当然，我们也无处不在的使用 MySQL ！</p><p>这篇文章主要介绍我们选择 <code>Clickhouse</code> 而不是 <code>ElasticSearch</code>（或 <code>MySQL</code> ）作为基础数据（服务请求日志）存储解决方案的主要原因（说明：出于 <code>OLTP</code> 的目的，我们仍会处使用 <code>MySQL</code> ）。</p><h2 id="1-SQL-支持-JSON-和-数组作为一等公民"><a href="#1-SQL-支持-JSON-和-数组作为一等公民" class="headerlink" title="1. SQL 支持, JSON 和 数组作为一等公民"></a>1. SQL 支持, JSON 和 数组作为一等公民</h2><p><code>SQL</code>是用于数据分析的理想语言。我喜欢<code>SQL</code>查询语言，<code>SQL schema</code>是无趣技术的完美示例，我建议在 99％ 项目中使用它从数据中发掘真相：项目代码不完美，而如果你的数据库是结构化 schema 存储的，就可以相对轻松地进行改造。反言之，如果数据库数据是一个巨大的 <code>JSON</code> 块（<code>NoSQL</code>），没有人可以完全掌握数据的清晰结构，那么重构将会遇到更多麻烦。</p><p>尤其是在使用 <code>MongoDB</code> 的老项目中，我看到了这种情况。每一次新的分析报告和每一个涉及数据迁移的重构都无比痛苦。如果是新建一个这样的项目还算有趣——因为不需要花太多时间详细设计项目结构，只要“看看它是如何能跑起来”就行，但是维护它将会非常无趣！</p><p>但是，重要的是要注意，这种经验法则（“使用严格schema”）对于日志存储用例而言并不那么关键。这就是 ElasticSearch 如此成功、具有许多优势和灵活架构的原因。</p><p>继续回到 <code>JSON</code> ，就 <code>JSON</code> 数据的查询、语法而言，传统的关系型数据库仍在追赶 <code>NoSQL</code> 数据库，我们必须承认 <code>JSON</code> 对动态结构化数据（如日志存储）而言，是非常方便的格式。</p><p><code>Clickhouse</code> 是一种在 JSON 已发展存在后（不同于 MySQL 和 Postgres ）设计和构建的现代引擎。由于 <code>Clickhouse</code> 不必背负这些流行的 RDBMS 向后兼容性和严格 SQL 标准，<code>Clickhouse</code> 团队可以在功能和改进方面更快速发展，实际上也的确是。 <code>Clickhouse</code> 的开发人员有更多机会在严格 <code>schema</code> 与 <code>JSON</code> 的灵活性之间达到最佳平衡，我认为他们在这方面做得很好。 <code>Clickhouse</code> 试图在分析领域与 <code>Google Big Query</code> 及其他主要对手竞争，因此它对“标准” <code>SQL</code> 进行了许多改进，这使其语法成为了杀手锏，在许多用于分析和计算目的情形下相比传统 <code>RDBMS</code> 更多优势。</p><p>一些基本的例子：</p><p>在 <code>MySQL</code> 中，你可以提取 <code>JSON</code> 字段，但是复杂的 JSON 处理仅在最新版本（<a href="https://mysqlserverteam.com/json_table-the-best-of-both-worlds/" target="_blank" rel="noopener">具有 JSON_TABLE 函数的版本8</a>）中可用。在 <code>PosgreSQL</code> 中，情况甚至更糟-在 PostgreSQL 12之前还没有直接的 JSON_TABLE 替代方案！</p><p>而这与 <code>Clickhouse</code> 的 JSON 及相关数组功能相比，也仅仅领先一小步。数组功能相关链接：</p><ul><li><a href="https://clickhouse.tech/docs/en/sql-reference/statements/select/array-join/" target="_blank" rel="noopener">arrayJoin</a></li><li><a href="https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/grouparray/" target="_blank" rel="noopener">groupArray</a></li><li><a href="https://clickhouse.tech/docs/en/sql-reference/functions/array-functions/#array-map" target="_blank" rel="noopener">arrayMap</a></li><li><a href="https://clickhouse.tech/docs/en/sql-reference/functions/array-functions/#array-filter" target="_blank" rel="noopener">arrayFilter</a></li></ul><p>在很多情况下，PostgreSQL 的 <code>generate_series()</code> 功能很有用。来自 ApiRoad 的一个具体示例：我们需要在chart.js 时间轴上映射请求数量。每天进行常规的<code>SELECT .. group by day</code>，但如果某些天没有任何查询时，就会出现间隙。但我们并不想要间隙，因此需要补零，对吧？ 这正是 PostgreSQL 中 <code>generate_series()</code> 函数有用的地方。在 MySQL 中，<a href="https://ubiq.co/database-blog/fill-missing-dates-in-mysql/" target="_blank" rel="noopener">推荐按日期创建表并进行连接</a>，不太优雅了吧？</p><p>如下是 <code>ElasticSearch</code> 中如何解决：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html#_missing_value_2" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html#_missing_value_2</a></p><p>关于查询语言：我对 ElasticSearch 的 Lucene 语法、HTTP API 以及为检索数据而编写 json 等几个方面仍然不满意。而 SQL 将是我的首选。</p><p>这是 <code>Clickhouse</code> 用于日期差填充时的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.timePeriod as t, b.count as c from (</span><br><span class="line">with (select toUInt32(dateDiff(&apos;day&apos;, [START_DATE], [END_DATE])) ) </span><br><span class="line">as diffInTimeUnits</span><br><span class="line">                </span><br><span class="line">select arrayJoin(arrayMap(x -&gt; (toDate(addDays([START_DATE], x))), range(0, diffInTimeUnits+1))) as timePeriod ) a</span><br><span class="line">            </span><br><span class="line">LEFT JOIN </span><br><span class="line">            </span><br><span class="line">(select count(*) as count, toDate(toStartOfDay(started_at)) as timePeriod from logs WHERE </span><br><span class="line">[CONDITIONS]</span><br><span class="line">GROUP BY toStartOfDay(started_at)) b on a.timePeriod=b.timePeriod</span><br></pre></td></tr></table></figure><p>在这里，我们通过 <code>lambda</code> 函数和循环生成一个虚拟表，然后再与按天分组的日志表进行左连接。</p><p>我认为 <code>arrayJoin</code> + <code>arrayMap</code> + <code>range</code> 函数方式相比 <code>generate_series()</code> 有更多灵活性。通过 <code>WITH FILL</code> 关键词可用于更简洁的语法。</p><h2 id="2-灵活的schema-但需要时也可以严格"><a href="#2-灵活的schema-但需要时也可以严格" class="headerlink" title="2. 灵活的schema - 但需要时也可以严格"></a>2. 灵活的schema - 但需要时也可以严格</h2><p>对于日志存储任务来说，数据schema通常会在项目生命周期中变化，<code>ElasticSearch</code> 允许将巨大的 JSON 块放入索引中，然后找出字段类型和索引部分。<code>Clickhouse</code> 也同样支持这种方法。可以将数据放入 JSON 字段并相对快速地进行过滤，尽管在TB级上并不会很快。然后，当你经常有在特定字段查询需要时，便可以在日志表中添加物化列（materialized columns），这些列能够即时的从 JSON 中提取值。对TB级数据查询时会更加快速。</p><p>我推荐 Altinity 关于日志存储中 JSON 与 表格式对比的专题视频：</p><p><a href="https://youtu.be/pZkKsfr8n3M" target="_blank" rel="noopener">https://youtu.be/pZkKsfr8n3M</a></p><h2 id="3-存储和查询效率"><a href="#3-存储和查询效率" class="headerlink" title="3. 存储和查询效率"></a>3. 存储和查询效率</h2><p>Clickhouse 在 <code>SELECT</code> 查询时非常快速，这在<a href="https://pixeljets.com/blog/clickhouse-as-a-replacement-for-elk-big-query-and-timescaledb/" target="_blank" rel="noopener">之前文章中已做讨论</a>。</p><p>有趣的是，<a href="https://youtu.be/pZkKsfr8n3M?t=2479" target="_blank" rel="noopener"><strong>有证据表明</strong></a>，与 ElasticSearch 相比，Clickhouse 的存储效率可以高出 5-6 倍，而从查询的角度看，它的字面速度也要快一个数量级。还有<a href="https://habr.com/ru/company/mkb/blog/472912/" target="_blank" rel="noopener"><strong>另一个例子</strong></a>。</p><p>我相信二者没有直接的基准对比测试，至少我还未找到，因为 Clickhouse 和 ElasticSearch 在查询语法、缓存实现及整体特性上都非常不同。</p><p>MySQL 时，在仅有1亿行日志数据的表上进行如索引失效的非最优查询，都会使服务器陷入缓慢并产生内存交换，因此 MySQL 并不适合大型日志查询。但就存储而言，压缩的 InnoDB 表并没有那么糟糕。由于其基于行的特性，与 Clickhouse 相比，数据压缩方面的情况要差得多（抱歉，这次没有相关链接），但是它仍然可以在不显著降低性能的情况下设法降低成本 。因此在某些情况下，对于少量日志来说，我们依然可以使用 InnoDB 表。</p><h2 id="4-统计函数"><a href="#4-统计函数" class="headerlink" title="4. 统计函数"></a>4. 统计函数</h2><p>在 Clickhouse 中，很容易计算 404 查询的中位数和 99 分位的耗时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*) as cnt, </span><br><span class="line">  quantileTiming(0.5)(duration) as duration_median, </span><br><span class="line">  quantileTiming(0.9)(duration) as duration_90th, </span><br><span class="line">  quantileTiming(0.99)(duration) as duration_99th</span><br><span class="line">  FROM logs WHERE status=404</span><br></pre></td></tr></table></figure><p>这里要注意 <code>quantileTiming</code> 函数的用法以及如何优雅地使用<a href="https://javascript.info/currying-partials" target="_blank" rel="noopener">currying</a>。Clickhouse 具有通用的分位数 <code>quantile</code> 函数！ 但是 <code>quantileTiming</code> 已<a href="https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/quantiletiming/#quantiletiming" target="_blank" rel="noopener">针对序列化数据进行了优化，比如加载网页时间或后端响应时间的日志</a>.</p><p>还有更多类似的，需要加权算术平均数吗？要计算线性回归吗？这很容易，只需使用专门的函数就可以。</p><p>这是 Clickhouse 相关统计函数的完整列表：</p><p><a href="https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/" target="_blank" rel="noopener">https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/</a></p><p>这些大部分在 MySQL 中都是有问题的。</p><p>ElasticSearch 在这方面比 MySQL 好得多，它既具有分位数又具有加权中位数，但是它还没有线性回归。</p><h2 id="5-MySQL-和-Clickhouse-紧密结合"><a href="#5-MySQL-和-Clickhouse-紧密结合" class="headerlink" title="5. MySQL 和 Clickhouse 紧密结合"></a>5. MySQL 和 Clickhouse 紧密结合</h2><p>MySQL 和 Clickhouse 有多种级别的相互集成，这使它们最小化数据重复的情况下非常方便在一起使用：</p><ul><li><a href="https://clickhouse.tech/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-sources/#dicts-external_dicts_dict_sources-mysql" target="_blank" rel="noopener">MySQL 作为外部词典</a></li><li><a href="https://clickhouse.tech/docs/en/engines/database-engines/materialize-mysql/#materialize-mysql" target="_blank" rel="noopener">通过binlog将 MySQL 数据镜像至 Clickhouse</a></li><li><a href="https://clickhouse.tech/docs/en/engines/database-engines/mysql/" target="_blank" rel="noopener">MySQL 数据库引擎</a> - 和之前方法相似但更灵活，无需 binlog</li><li><a href="https://clickhouse.tech/docs/en/sql-reference/table-functions/mysql/" target="_blank" rel="noopener">MySQL 表函数</a> 通过特定查询链接 MySQL 表</li><li><a href="https://clickhouse.tech/docs/en/engines/table-engines/integrations/mysql/" target="_blank" rel="noopener">MySQL 表引擎</a> 在 CREATE TABLE 语句中静态描述特定表</li><li><a href="https://clickhouse.tech/docs/en/interfaces/mysql/" target="_blank" rel="noopener">Clickhouse 使用 MySQL 协议</a></li></ul><p>我不能肯定地说动态数据库和表引擎在 <code>JOIN</code> 上有多么快速和稳定，这肯定是需要基准测试的。但这个概念非常吸引人-你已经可以在 Clickhouse 数据库上完整地复制 MySQL 表 ，而不必处理缓存失效和重新设置索引。</p><p>关于将 MySQL 与 Elasticsearch 结合使用，我的有限经验表明，这两种技术有太多不同。我的印象是他们彼此各说各话，并不会组合出现。所以我通常只需要把 ElasticSearch 需要索引的数据 JSON 化，然后发送到 ElasticSearch 。之后，MySQL 数据一些迁移或任何变更操作（ <code>UPDATE/REPLACE</code> ）之后，在 Elasticseach 端找出需要重新索引的部分。关于 MySQL 和 ElasticSearch 的数据同步，这是一篇<a href="https://www.elastic.co/blog/how-to-keep-elasticsearch-synchronized-with-a-relational-database-using-logstash" target="_blank" rel="noopener">基于 Logstash 实现的文章</a>。我不太喜欢 Logstash ，因为它的性能一般，对内存要求也很高，同时它也会成为系统中不稳定因素。对于使用 MySQL 的简单项目中，数据同步和索引往往是阻止我们使用 Elasticsearch 的因素。</p><h2 id="6-新特性"><a href="#6-新特性" class="headerlink" title="6. 新特性"></a>6. 新特性</h2><p>是否想要附加 S3 存储的 <code>CSV</code>，并将其作为 Clickhouse 中的表？<a href="https://clickhouse.tech/docs/en/engines/table-engines/integrations/s3/" target="_blank" rel="noopener">这非常简单</a>。</p><p>是否要更新或删除日志行以符合数据保护规范？ 现在，这很容易！</p><p>在我 2018 年写第一篇文章时，Clickhouse 还没有简单的方法来删除或更新数据，这是一个真正的弊端。现在，这不再是问题。Clickhouse 利用自定义 SQL 语法删除数据行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE [db.]table [ON CLUSTER cluster] DELETE WHERE filter_expr</span><br></pre></td></tr></table></figure><p>原因很明确，对于 Clickhouse（和其他列式数据库）来说，删除仍然是一项相当昂贵的操作，因此最好不要生产环境频繁使用。</p><h2 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7. 缺点"></a>7. 缺点</h2><p>与 ElasticSearch 相比，Clickhouse 也有缺点。首先，如果构建用于日志存储的内部分析，那么就需要最好的 GUI 工具。Kibana 目前在这方面相比 Grafana 会是很好的选择（至少，这种观点非常流行，Grafana UI 有时并不那么顺滑）。如果使用 Clickhouse ，则必须使用 Grafana 或 Redash 。（我们喜欢的 <a href="https://github.com/enqueue/metabase-clickhouse-driver" target="_blank" rel="noopener">Metabase</a> 也获得了 Clickhouse 的支持！）</p><p>但是，在我们的案例中，我们正在构建面向用户的分析方法，因此无论如何我们都必须从头开始构建分析 GUI（我们使用 Laravel，Inertia.js，Vue.js 和 Charts.js 来实现用户界面）。</p><p>另一个与生态系统有关的问题是：消费、处理、发送数据到 Clickhouse 的工具是有限制。对于 Elasticsearch，有Logstash 和 filebeat，它们是 Elastic 生态系统固有的工具，旨在完美地协同工作。幸运的是，Logstash 也可以用于将数据放入Clickhouse，从而缓解了该问题。在 ApiRoad 中，我们使用了自己定制的 Node.js 日志传送程序，该程序将日志汇总，然后分批发送给 Clickhouse（因为 Clickhouse 喜欢大批处理，而不是小的多次插入）。</p><p>我在 Clickhouse 中不喜欢的还有一些函数的奇怪命名，这是因为 Clickhouse 是由 Yandex.Metrika（ Google 分析的竞争对手）创建的。比如，<code>visitParamHas()</code> 是用于检查JSON中是否存在特定键。通用目的，但并不是通用名称。有一堆名字不错的JSON函数名，例如 <code>JSONHas()</code>。还有一个有趣的细节：据我所知，它们使用不同的 <a href="https://github.com/simdjson/simdjson" target="_blank" rel="noopener">JSON解析引擎</a>，虽然更符合标准，但速度稍慢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ElasticSearch 是一个非常强大的解决方案，但我认为它最强的方面仍然是超过 10+ 节点的支持，用于大型全文检索和 facets ，复杂的索引和分值计算-这是 ElasticSearch 的亮点。当我们提及时间序列和日志存储时，似乎有更好的解决方案，而 Clickhouse 就是其中之一。ElasticSearch API 的功能非常强大，但在很多情况下，如果不从文档中复制具体 HTTP 请求，就很难记住如何做一件事，它有更多的“企业化”和“ Java 风格”。Clickhouse 和 lasticSearch 都是占用内存很大的程序， Clickhouse 内存要求为4GB，而 ElasticSearch 的内存要求为 16GB 。我还认为 Elastic 团队关注的重点是他们新的<a href="https://www.elastic.co/what-is/elasticsearch-machine-learning" target="_blank" rel="noopener">机器学习功能</a>，我的愚见是，尽管这些功能听起来非常新潮，但不论你拥有多少开发人员和金钱，这些庞大的功能集很难持续支持和改进。对我来说，ElasticSearch 在不断的进入“博而不精”的状态。或许，是我错了。</p><p>Clickhouse 则与众不同。设置简单、<code>SQL</code> 也简单、控制台客户端也很棒。通过少量配置，就可以让一切简单有效的工作起来，但是当有需要时，也可以在 <code>TB</code> 级数据上使用丰富的特性、副本和分片能力。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://pixeljets.com/blog/clickhouse-vs-elasticsearch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pixeljets.com/blog/clickhouse-vs-elasticsearch/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：Anton Sidashin&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/gocn/translator/blob/master/2021/w10_Clickhouse_for_log_storage_and_analysis_in_2021.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gocn/translator/blob/master/2021/w10_Clickhouse_for_log_storage_and_analysis_in_2021.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/fivezh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fivezh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对：&lt;a href=&quot;https://github.com/watermelo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咔叽咔叽&lt;/a&gt;</summary>
    
    
    
    
    <category term="Clickhouse" scheme="http://fivezh.github.io/tags/Clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>Golang new VS make</title>
    <link href="http://fivezh.github.io/2020/03/15/golang-new-make/"/>
    <id>http://fivezh.github.io/2020/03/15/golang-new-make/</id>
    <published>2020-03-15T09:01:17.000Z</published>
    <updated>2020-04-13T15:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Golang中new和make的区别？</li><li>复杂结构的类型如何正确初始化</li></ul><a id="more"></a><h2 id="new-vs-make"><a href="#new-vs-make" class="headerlink" title="new() vs make()"></a><code>new()</code> vs <code>make()</code></h2><p>需要区分在Golang中<code>声明</code>、<code>初始化</code>的区别？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> <span class="comment">// 声明，未初始化，此时为nil slice</span></span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new()"></a><code>new()</code></h3><blockquote><p>The built-in function new takes a type T, allocates storage for a variable of that type at run time, and returns a value of type *T pointing to it.The variable is initialized as described in the section on initial values.</p></blockquote><p><code>new()</code>是内存分配的内置函数，传入类型<code>T</code>，则在运行时分配内存，返回<code>*T</code>类型的值（指向新分配内存地址的指针）。</p><p>变量将按照<code>类型对应的零值</code>来进行初始化，如map/slice零值均为nil。</p><h3 id="make"><a href="#make" class="headerlink" title="make()"></a><code>make()</code></h3><blockquote><p>The built-in function make takes a type T, which must be a slice, map or channel type, optionally followed by a type-specific list of expressions. It returns a value of type T (not *T). The memory is initialized as described in the section on initial values.</p></blockquote><p>内置函数<code>make()</code>仅支持特定类型参数(slice/map/channel)，返回类型为T的变量值（注意：new返回*T类型值，make返回T类型值）。变量初始化和<code>new</code>保持一致的策略，均按零值处理。</p><ul><li>slice</li><li>map</li><li>channel</li><li>或者上述类型，再加其他参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Call             Type T     Result</span><br><span class="line"></span><br><span class="line">make(T, n)       slice      slice of <span class="built_in">type</span> T with length n and capacity n</span><br><span class="line">make(T, n, m)    slice      slice of <span class="built_in">type</span> T with length n and capacity m</span><br><span class="line"></span><br><span class="line">make(T)          map        map of <span class="built_in">type</span> T</span><br><span class="line">make(T, n)       map        map of <span class="built_in">type</span> T with initial space <span class="keyword">for</span> approximately n elements</span><br><span class="line"></span><br><span class="line">make(T)          channel    unbuffered channel of <span class="built_in">type</span> T</span><br><span class="line">make(T, n)       channel    buffered channel of <span class="built_in">type</span> T, buffer size n</span><br></pre></td></tr></table></figure><h2 id="复杂结构体的初始化"><a href="#复杂结构体的初始化" class="headerlink" title="复杂结构体的初始化"></a>复杂结构体的初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    d []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">    e <span class="keyword">int</span></span><br><span class="line">    f *Foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面<code>Foo</code>类型的复合结构，初始化时要注意下，直接<code>new Foo()</code>的对象中map是没有分配空间的，也就是<code>nil map</code>，此时不能直接使用。</p><p>下面的代码，会抛出panic：<code>panic: assignment to entry in nil map</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h1 := &amp;Foo&#123;&#125;</span><br><span class="line"><span class="comment">// h1 := new(Foo)和上面代码等价</span></span><br><span class="line">h1.c[<span class="number">1</span>] = <span class="number">111</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">h1.d = <span class="built_in">append</span>(h1.d, <span class="number">1</span>) <span class="comment">// nil slice可通过append追加元素</span></span><br></pre></td></tr></table></figure><p>正确的用法：定义类型对应的<code>NewTypeName()</code>方法专门用于类型初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">()</span> *<span class="title">Foo</span></span> &#123;</span><br><span class="line">    foo := <span class="built_in">new</span>(Foo)</span><br><span class="line">    foo.c = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBar</span><span class="params">()</span> *<span class="title">Bar</span></span> &#123;</span><br><span class="line">    bar := <span class="built_in">new</span>(Bar)</span><br><span class="line">    bar.f = NewFoo()</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    h1 := NewFoo()</span><br><span class="line">    h1.c[<span class="number">1</span>] = <span class="number">11</span></span><br><span class="line">    fmt.Println(h1)</span><br><span class="line"></span><br><span class="line">    h2 := NewBar()</span><br><span class="line">    h2.f.c[<span class="number">2</span>] = <span class="number">22</span> <span class="comment">// 可以正确写入map元素</span></span><br><span class="line">    fmt.Println(*h2.f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><code>make</code>仅用于<code>map</code>、<code>slice</code>、<code>channel</code></li><li><code>new</code>可用于类型T的内存分配，类型各字段初始值为类型对应零值</li><li>复合类型，多通用<code>NewTypeName()</code>自定义函数，返回新建类型变量，而类型内字段在此方法内进行有效的内存分配操作。（如map应通过make开辟空间）</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://golang.org/ref/spec#Making_slices_maps_and_channels" target="_blank" rel="noopener">spec#Making_slices_maps_and_channels-make关键词</a></li><li><a href="https://golang.org/ref/spec#Allocation" target="_blank" rel="noopener">spec#Allocation-new关键词</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Golang中new和make的区别？&lt;/li&gt;
&lt;li&gt;复杂结构的类型如何正确初始化&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>理解Golang中的 nil</title>
    <link href="http://fivezh.github.io/2020/03/09/golang-nil/"/>
    <id>http://fivezh.github.io/2020/03/09/golang-nil/</id>
    <published>2020-03-09T07:23:18.000Z</published>
    <updated>2020-03-21T16:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>官方语言规范中关于零值的说明：<a href="https://golang.org/ref/spec#The_zero_value" target="_blank" rel="noopener">spec#The_zereo_value</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool      -&gt; <span class="literal">false</span></span><br><span class="line">numbers -&gt; 0</span><br><span class="line">string    -&gt; <span class="string">""</span></span><br><span class="line">pointers -&gt; nil</span><br><span class="line">slices -&gt; nil</span><br><span class="line">maps -&gt; nil</span><br><span class="line">channels -&gt; nil</span><br><span class="line"><span class="built_in">functions</span> -&gt; nil</span><br><span class="line">interfaces -&gt; nil</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/assets/post_images/nil.png" alt="zero value"></p><h2 id="什么是nil"><a href="#什么是nil" class="headerlink" title="什么是nil"></a>什么是<code>nil</code></h2><p>根据官方定义，nil是预定义标识，代表了<code>指针pointer</code>、<code>通道channel</code>、<code>函数func</code>、<code>接口interface</code>、<code>map</code>、<code>切片slice</code>类型变量的零值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil is a predeclared identifier representing the zero value <span class="keyword">for</span> a pointer, channel, func, interface, map, or slice <span class="built_in">type</span>.</span><br></pre></td></tr></table></figure><p>也就是说，nil仅是下列6中类型的零值：</p><ul><li>pointer</li><li>channel</li><li>func</li><li>interface</li><li>map</li><li>slice</li></ul><blockquote><p>注意：struct类型零值不是nil，而是各字段值为对应类型的零值。且不能将struct类型和nil进行等值判断，语法校验不通过。</p></blockquote><p>如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; i <span class="keyword">int</span>; f <span class="keyword">float64</span>; next *T &#125;</span><br><span class="line">t := <span class="built_in">new</span>(T) <span class="comment">// 此时，var t2 T效果相当，只是t为指针，而t2为类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么存在如下：</span></span><br><span class="line">t.i == <span class="number">0</span></span><br><span class="line">t.f == <span class="number">0.0</span></span><br><span class="line">t.next == <span class="literal">nil</span>  <span class="comment">// 指针类型的零值为nil</span></span><br></pre></td></tr></table></figure><h2 id="详细看看各类型nil的情况"><a href="#详细看看各类型nil的情况" class="headerlink" title="详细看看各类型nil的情况"></a>详细看看各类型nil的情况</h2><h3 id="nil-pointer"><a href="#nil-pointer" class="headerlink" title="nil pointer"></a>nil pointer</h3><ul><li>指针的零值是<code>nil</code></li><li>只声明、未指向具体地址的指针，此时为<code>nil</code></li><li><code>nil</code>指针依然可以正常调用指针对象的方法</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">p == <span class="literal">nil</span> <span class="comment">// true</span></span><br><span class="line">*p <span class="comment">// panic: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>在<code>Golang</code>中指针区别几乎和C/C++中功能相近（都是指向内存地址），区别在于：</p><ul><li>无需担心内存泄露，即内存安全</li><li>GC垃圾回收</li></ul><h3 id="nil-slice"><a href="#nil-slice" class="headerlink" title="nil slice"></a><code>nil slice</code></h3><p>切片的零值是nil，所以只声明变量时，其缺省值为零值nil，这时也就是我们所说的<code>nil slice</code>。<br>nil切片不能直接访问元素值，但可通过<code>append()</code>追加元素。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil slices</span></span><br><span class="line"><span class="keyword">var</span> s []slice</span><br><span class="line"><span class="built_in">len</span>(s)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cap</span>(s)  <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s  <span class="comment">// iterates zero times</span></span><br><span class="line">s[i]  <span class="comment">// panic: index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 []<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, a1) <span class="comment">// []int(nil)</span></span><br><span class="line">a2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, a2) <span class="comment">// []int&#123;&#125;</span></span><br><span class="line">a3 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, a3) <span class="comment">// []int&#123;&#125;，等价于make效果</span></span><br></pre></td></tr></table></figure><h3 id="nil-map"><a href="#nil-map" class="headerlink" title="nil map"></a><code>nil map</code></h3><ul><li>只声明一个map类型变量时，为<code>nil map</code></li><li>此时为<strong>只读map</strong>，无法进行写操作，否则会触发panic</li><li><code>nil map</code>和<code>empty map</code>区别：<ul><li><code>nil map</code>：只声明未初始化，此时为只读map，不能写入操作，示例：<code>var m map[t]v</code></li><li><code>empty map</code>：空map，已初始化，可写入，示例：<code>m := map[t]v{}</code>或<code>m := make(map[string]string, 0)</code></li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil maps</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[t]u <span class="comment">// nil map</span></span><br><span class="line">m2 := <span class="keyword">map</span>[t]u&#123;&#125; <span class="comment">// empty map</span></span><br><span class="line"><span class="built_in">len</span>(m)  <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> m <span class="comment">// iterates zero times</span></span><br><span class="line">v, ok := m[i] <span class="comment">// zero(u), false</span></span><br><span class="line">m[i] = x <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure><p>一个常见的应用场景，NewX返回特定类型对象：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(*http.Request, error)</span></span> &#123;</span><br><span class="line">  req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    req.Header.Set(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义header</span></span><br><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">"USER_AGENT"</span>: <span class="string">"golang/gopher"</span>,</span><br><span class="line">&#125;,)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无自定义header时，传empty map</span></span><br><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 无自定义header，也可以传nil map</span></span><br><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="nil-channel"><a href="#nil-channel" class="headerlink" title="nil channel"></a><code>nil channel</code></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil channels</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> t</span><br><span class="line">&lt;- c      <span class="comment">// blocks forever</span></span><br><span class="line">c &lt;- x    <span class="comment">// blocks forever</span></span><br><span class="line"><span class="built_in">close</span>(c)  <span class="comment">// panic: close of nil channel</span></span><br></pre></td></tr></table></figure><h3 id="nil-func"><a href="#nil-func" class="headerlink" title="nil func"></a><code>nil func</code></h3><p><code>map</code>、<code>channel</code>、<code>function</code>的本质都是指向具体实现的指针，而对应类型的nil则是不指向任何地址。</p><h3 id="nil-interface"><a href="#nil-interface" class="headerlink" title="nil interface"></a><code>nil interface</code></h3><p>interface底层由两部分组成：类型、值(type, value)，当二者均为nil时，此时interface才为nil。</p><h4 id="nil-nil-is-nil"><a href="#nil-nil-is-nil" class="headerlink" title="(nil, nil) is nil"></a>(nil, nil) is <code>nil</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s fmt.Stringer    <span class="comment">// Stringer (nil, nil)</span></span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>结论1</strong>：<code>interface (nil, nil) == nil</code>，类型和值均为nil的interface，等于nil</p><h4 id="type-nil-is-not-nil"><a href="#type-nil-is-not-nil" class="headerlink" title="(type, nil) is not nil"></a>(type, nil) is not <code>nil</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *Person           <span class="comment">// nil of type *Person</span></span><br><span class="line"><span class="keyword">var</span> s fmt.Stringer = p  <span class="comment">// Stringer (*Person, nil)</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, s)  <span class="comment">// 注意，此时打印输出为(*Person)(nil)，无任何是interface的体现</span></span><br><span class="line">fmt.Println(s == <span class="literal">nil</span>)   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="不要返回具体的错误类型，而应直接返回nil"><a href="#不要返回具体的错误类型，而应直接返回nil" class="headerlink" title="不要返回具体的错误类型，而应直接返回nil"></a>不要返回具体的错误类型，而应直接返回<code>nil</code></h4><p>下面展示返回类型为interface时的差异：</p><p>错误示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;   <span class="comment">// error(*doError, nil)</span></span><br><span class="line">  <span class="keyword">var</span> err *doError</span><br><span class="line">  <span class="keyword">return</span> err  <span class="comment">// nil of type *doError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := do()             <span class="comment">// error(*doError, nil)</span></span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> *<span class="title">doError</span></span> &#123;   <span class="comment">// nil of type *doError</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := do()             <span class="comment">// nil of type *doError</span></span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下面这段代码，虽然<code>do()</code>返回nil，但<code>wrapDo()</code>返回依然是接口，也就是<code>类型为*doError，值为nil</code>的接口，此时拿到的返回值并不等于nil。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> *<span class="title">doError</span></span> &#123;  <span class="comment">// nil of type *doError</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapDo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="comment">// error (*doError, nil)</span></span><br><span class="line">  <span class="keyword">return</span> do()       <span class="comment">// nil of type *doError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := wrapDo()   <span class="comment">// error  (*doError, nil)</span></span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nil的有效利用"><a href="#nil的有效利用" class="headerlink" title="nil的有效利用"></a><code>nil</code>的有效利用</h2><ul><li><code>nil</code>类型接收者是可以正确调用方法的 <code>nil reveivers are userful</code></li><li><code>Keep nil (pointer) useful if possible, if not NewX()</code></li><li><code>Use nil slices, they&#39;re often fast enough</code></li><li><code>Use nil maps as read-only empty maps</code>，将nil map作为只读的空map（不能读nil map进行写入操作，否则会发生panic）</li><li><code>Use nil channel to disable a select case</code>，nil channel来阻塞selct/case语句</li><li><code>nil value can satisfy interface</code>，不同类型的nil值可满足interface，也就是可赋值给interface</li><li><code>Use nil interface to signal defaul</code>，使用nil的interface来标识使用缺省处理</li><li><code>nil is an important part Go</code></li></ul><p><img src="/assets/post_images/nil-useful.png" alt="nis-useful"></p><h3 id="nil-pointer用法"><a href="#nil-pointer用法" class="headerlink" title="nil pointer用法"></a><code>nil pointer</code>用法</h3><ul><li><code>nil pointer</code>用来和nil比较确认是否为零值</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">p == <span class="literal">nil</span> <span class="comment">// true</span></span><br><span class="line">*p <span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>来看看，如何实现二叉树树的求和操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree &#123;</span><br><span class="line">  v <span class="keyword">int</span></span><br><span class="line">  l *tree</span><br><span class="line">  r *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>第一种方案，有两个问题：</p><ul><li>代码冗余，重复的<code>if v != nil {v.m()}</code></li><li>当<code>t</code>为nil时，会发生<code>panic</code></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t *tree <span class="comment">// nil of type *tree</span></span><br><span class="line">sum := t.Sum() <span class="comment">// panic</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方案1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sum := t.v</span><br><span class="line">  <span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.l.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.r.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nil</code>接收者，也可以正确调用方法，所以可以利用这一点，改造出方案2：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案2：代码简洁、可断性提高很多</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v + t.l.Sum() + t.r.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过利用类型的nil，可以灵活实现是否为空的处理，已经便捷实现扩展函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(t.l, t.v, t.r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Find</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.v == v || t.l.Find(v) || t.r.Find(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nil-slices用法"><a href="#nil-slices用法" class="headerlink" title="nil slices用法"></a><code>nil slices</code>用法</h3><ul><li>不能对<code>nil slice</code>进行取值，否则会发生panic</li><li>可通过<code>append</code>函数对<code>nil slice</code>进行增加元素操作</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s <span class="comment">// 执行0次</span></span><br><span class="line">s[i] <span class="comment">// panic: index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"len: %2d, cap: %2d\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">  s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nil-map用法"><a href="#nil-map用法" class="headerlink" title="nil map用法"></a><code>nil map</code>用法</h3><ul><li><code>nil map</code>不能进行增加元素操作，因它还没有进行初始化</li><li>将<code>nil map</code>作为只读的空map</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[t]u</span><br><span class="line"><span class="built_in">len</span>(m) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> m <span class="comment">// 执行0次</span></span><br><span class="line">v, ok := m[i] <span class="comment">// v=zero(u), ok=false</span></span><br><span class="line">m[i] = x      <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有个nil map有用的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><span class="params">(*http.Request, error)</span></span>  &#123;</span><br><span class="line">  req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    req.Header.Set(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时，传递headers</span></span><br><span class="line">NewGet(</span><br><span class="line">  <span class="string">"http://google.com"</span>,</span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"USER_AGENT"</span>:<span class="string">"google/gopher"</span>,</span><br><span class="line">  &#125;,  <span class="comment">// go语言五十度灰，如果参数和)之间换行形式，参数尾部需追加,逗号</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时，不传递headers，可以传递一个empty map空map</span></span><br><span class="line">NewGet(</span><br><span class="line">  <span class="string">"http://google.com"</span>,</span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;, <span class="comment">// 传递空map，empty map</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时，不传递headers，可以传递一个nil map</span></span><br><span class="line">NewGet(</span><br><span class="line">  <span class="string">"http://google.com"</span>,</span><br><span class="line">  <span class="literal">nil</span>, <span class="comment">// 传递nil map，也是合法的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="nil-channel用法"><a href="#nil-channel用法" class="headerlink" title="nil channel用法"></a><code>nil channel</code>用法</h3><ul><li>不能对<code>nil channel</code>进行<code>close()</code>操作，发触发<code>panic: close of nil channel</code></li><li>不能对channel进行多次<code>close</code>，会触发 <code>panic: close of closed channel</code></li><li>关闭channel，在select/case中将依然能获取到值，但nil channel将阻塞读操作来失效select/case中逻辑</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> t <span class="comment">// nil of type chan t</span></span><br><span class="line"><span class="comment">// nil channel操作时</span></span><br><span class="line">&lt;- c <span class="comment">// block forever，持续阻塞</span></span><br><span class="line">c &lt;- x <span class="comment">// block forever，持续阻塞</span></span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">// panic: close of nil channel，关闭nil channel发生panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于已关闭的channel，将发生如下现象</span></span><br><span class="line">v, ok := &lt;-c  <span class="comment">// zero(t), false 不会阻塞，返回零值和False</span></span><br><span class="line">c &lt;-x <span class="comment">// panic: send to close channel</span></span><br><span class="line"><span class="built_in">close</span>(x) <span class="comment">// panic: close of closed channel，备注原文中错误</span></span><br></pre></td></tr></table></figure><p>现在假设要实现一个合并函数，实现从两个通道中获取数据，然后写入out输出通道：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a,b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v:= &lt;-a: <span class="comment">// 当a/b通道关闭时，这里将持续获取到0</span></span><br><span class="line">        out &lt;-v</span><br><span class="line">      <span class="keyword">case</span> v:= &lt;-b</span><br><span class="line">        out &lt;-v</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于a/b通道关闭的情况，改造代码如下:</span></span><br><span class="line"><span class="comment">// 此时不会获取到零值，但是可能会发生panic, deadlock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a,b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> aClosed, bClosed <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !aClosed || !bClosed &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v,ok := &lt;-a: <span class="comment">// 此时通道关闭后，就不会再进行获取了</span></span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        aClosed = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v</span><br><span class="line">    <span class="keyword">case</span> v,ok := &lt;-b:</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        bClosed = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通道不使用后应关闭：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a,b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> aClosed, bClosed <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> !aClosed || !bClosed &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v,ok := &lt;-a: <span class="comment">// 此时通道关闭后，就不会再进行获取了</span></span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        aClosed = <span class="literal">true</span></span><br><span class="line">        fmt.Println(<span class="string">"a is closed"</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v</span><br><span class="line">    <span class="keyword">case</span> v,ok := &lt;-b:</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        bClosed = <span class="literal">true</span></span><br><span class="line">        fmt.Println(<span class="string">"b is closed"</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      out &lt;-v</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out) <span class="comment">// 需要再不使用后进行close操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于搞定了，提交代码，转交给测试吧！你会发现CPU莫名燃烧了自我，为什么？因为外部逻辑如果关闭了a/b，此时上述代码中会有空转的逻辑，运行下，看看打印输出：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a is closed</span><br><span class="line">a is closed</span><br><span class="line">a is closed</span><br><span class="line">a is closed</span><br><span class="line">a is closed <span class="comment">// 很多次无用的空转逻辑</span></span><br><span class="line">b is closed <span class="comment">// 最后一次，a/b都未空时才结束循环</span></span><br></pre></td></tr></table></figure><p>可能看到这里已经有些蒙了，但要明白，无论是否关闭一个chanel，都可以从中读取到值，而如果不需要对channel取值操作了，那么可以将其改为nil，这样会永远阻塞读，防止再发生读操作；同时应在入口增加非nil判断。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a: <span class="comment">// 此时通道关闭后，就不会再进行获取了</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line">fmt.Println(<span class="string">"a is closed"</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">out &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line">fmt.Println(<span class="string">"b is closed"</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">out &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out) <span class="comment">// 需要再不使用后进行close操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nil-func用法"><a href="#nil-func用法" class="headerlink" title="nil func用法"></a><code>nil func</code>用法</h3><ul><li>go中函数是一等公民</li><li>函数可以作为struct结构体的字段，缺省值则为nil</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span> // <span class="title">f</span> <span class="title">is</span> <span class="title">type</span> <span class="title">of</span> <span class="title">func</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 常见用法，传输函数为<span class="title">nil</span>，增加缺省处理</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewServer</span><span class="params">(logger <span class="keyword">func</span>(<span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">    logger = log.Printf</span><br><span class="line">  &#125;</span><br><span class="line">  logger.Printf(<span class="string">"initializng %s"</span>, os.Getenv(<span class="string">"hostname"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nil-interface用法"><a href="#nil-interface用法" class="headerlink" title="nil interface用法"></a><code>nil interface</code>用法</h3><ul><li>将<code>nil interface</code>作为一种信号来使用</li><li>nil指针，不等于nil接口</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Summer intface &#123;</span><br><span class="line">  Sum() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *tree <span class="comment">// nil of type *tree</span></span><br><span class="line"><span class="keyword">var</span> s Summer = t <span class="comment">// nil指针，可以是合法的interface类型的值</span></span><br><span class="line"><span class="comment">// 此时，对接接口类型变量s而言，其类型为*tree，值为nil，也就是说(*tree, nil)行的interface</span></span><br><span class="line">fmt.Println(t==<span class="literal">nil</span>, s.Sum()) <span class="comment">// true, 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ints []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *ints)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  s := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> i&#123;</span><br><span class="line">    s += v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i ints</span><br><span class="line"><span class="keyword">var</span> s Sumer = i <span class="comment">// nil value can satisfy interface</span></span><br><span class="line">fmt.Println(s==<span class="literal">nil</span>, s.Sum()) <span class="comment">// true, 0</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过判断接口为nil，来给定缺省值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSum</span><span class="params">(s Summer)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.Sum()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *tree</span><br><span class="line">doSum(t) <span class="comment">// interface的类型和值分别为：(*tree, nil)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i ints</span><br><span class="line">doSum(i) <span class="comment">// (ints, nil)</span></span><br><span class="line"></span><br><span class="line">doSum(<span class="literal">nil</span>) <span class="comment">// (nil, nil)</span></span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>) <span class="comment">// 传递nil，则使用缺省处理</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/assets/post_images/kinds-of-nil.png" alt="Kinds of nil"></p><p>slice的零值<code>nil slice</code>，通过<code>append()</code>函数可以给<code>nil slice</code>进行增加元素操作；而对于map则不然，一个<code>nil map</code>，是不能直接进行复制的，必须进行<code>make</code>操作进行初始化开辟内存空间。</p><p>这是有一定混淆的。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://www.youtube.com/watch?v=ynoY2xz-F8s" target="_blank" rel="noopener">Video by Francesc老哥视频很赞，强烈推荐 - Understanding nil</a></li><li><a href="https://www.gmarik.info/blog/2016/understanding-golang-nil-value/" target="_blank" rel="noopener">Gmarik - Understanding Go’s <code>nil</code> value</a></li><li><a href="https://go101.org/article/nil.html" target="_blank" rel="noopener">go101 - nils in Go</a></li><li><a href="https://www.jianshu.com/p/dd80f6be7969" target="_blank" rel="noopener">理解Go语言的nil</a></li><li><a href="https://go101.org/article/nil.html" target="_blank" rel="noopener">go101-nil</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;零值&quot;&gt;&lt;a href=&quot;#零值&quot; class=&quot;headerlink&quot; title=&quot;零值&quot;&gt;&lt;/a&gt;零值&lt;/h2&gt;&lt;p&gt;官方语言规范中关于零值的说明：&lt;a href=&quot;https://golang.org/ref/spec#The_zero_value&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spec#The_zereo_value&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool      -&amp;gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers -&amp;gt; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string    -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pointers -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;slices -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;maps -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;channels -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;functions&lt;/span&gt; -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;interfaces -&amp;gt; nil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB 锁机制</title>
    <link href="http://fivezh.github.io/2020/01/31/mysql-lock/"/>
    <id>http://fivezh.github.io/2020/01/31/mysql-lock/</id>
    <published>2020-01-31T15:46:17.000Z</published>
    <updated>2020-01-31T15:46:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL InnoDB引擎锁机制主要有「共享锁Shared Lock」、「排他锁Exclusive Lock」，另外还有「意向锁Intention Lock」，从锁的粒度上来看我们主要关注表锁（Table Lock）、行锁（Row Lock）、以及通过意向锁实现更细粒度的锁。<br><a id="more"></a></p><p>锁，是操作系统中用于「管理对共享资源的并发访问」的机制。存在「临界资源」的「并发读写访问」时，为保证数据一致性，锁是其中的一种重要手段。</p><h2 id="一、不同类型的锁"><a href="#一、不同类型的锁" class="headerlink" title="一、不同类型的锁"></a>一、不同类型的锁</h2><h3 id="1-1-共享锁-Shared-Lock"><a href="#1-1-共享锁-Shared-Lock" class="headerlink" title="1.1 共享锁 Shared Lock"></a>1.1 共享锁 Shared Lock</h3><p>S锁，又称为「读锁Read Lock」，共享访问权限，或者说相互不会阻塞。<br>多个客户端在同一时刻可以同时读取同一个资源，而互不干扰。</p><h3 id="1-2-排他锁-Exclusive-Lock"><a href="#1-2-排他锁-Exclusive-Lock" class="headerlink" title="1.2 排他锁 Exclusive Lock"></a>1.2 排他锁 Exclusive Lock</h3><p>X锁，又称为「写锁Write Lock」，特点是排他，一个写锁会阻塞其他的写锁和读锁。<br>这是出于安全的考虑，只有如此才能保证再给定时间内，只有一个用户执行写入，防止其他用户读取正在写入的统一资源。</p><p><img src="/assets/post_images/SharedLock-ExclusiveLock.png" alt="SharedLock Vs ExclusiveLock"></p><h3 id="1-3-意向锁-Intention-Lock"><a href="#1-3-意向锁-Intention-Lock" class="headerlink" title="1.3 意向锁 Intention Lock"></a>1.3 意向锁 Intention Lock</h3><p>上述两种锁对InnoDB而言，都是行锁级别的锁；而更细粒度的，可以允许事务同时在行级、表级加锁。<br>I锁，意向锁，又分为两类：意向共享锁（IS Lock）、意向排他锁（IX Lock），下面逐一详述。</p><blockquote><p>意向锁，是在表级设置的一种锁，意在表名当前事务将在行级上增加什么类型的锁（S锁或X锁）</p></blockquote><ul><li>意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。</li></ul><p>通过命令<code>show engine innodb status</code>查看存储引擎的锁请求情况，类似如下内容：<code>TABLE LOCK table xxx trx id 10080 lock mode IX</code></p><p>意向锁的加锁规则：</p><ul><li>事务在获取行级S锁之前，必须获取其对应表的IS或IX锁</li><li>事务在获取行级X锁之前，必须获取其对应表的IX锁</li></ul><p><img src="/assets/post_images/IS-IX-Lock.png" alt="不同锁兼容性"></p><p>当事务申请锁和表、行已存在的锁兼容时，该锁被授权；否则，则锁等待。意向锁的主要目的是表明：存在请求正在或即将锁定此表的某行。意向锁除了全表请求（例如<code>LOCK TABLES ... WRITE</code>）外，不阻止任何其他内容。</p><h2 id="InnoDB-锁相关的表"><a href="#InnoDB-锁相关的表" class="headerlink" title="InnoDB 锁相关的表"></a>InnoDB 锁相关的表</h2><p><code>infomation_schema</code>库中存在三张与锁有关的数据表，分别是：</p><ul><li>INNODB_TRX：事务信息表，记录事务完整信息<ul><li>表结构：<img src="/assets/post_images/innodb_trx.png" alt="innodb_trx"></li><li><code>INNODB_TRX.trx_requested_lock_id</code>：事务等待的锁id，也就是后文中<code>INNODB_LOCKS.lock_id</code></li><li><code>INNODB_TRX.trx_state</code>：事务状态，<code>Lock Wait</code>表示锁等待状态</li><li><code>INNODB_TRX.trx_query</code>：事务执行SQL</li></ul></li><li>INNODB_LOCKS：锁信息表，记录锁完整信息<ul><li><img src="/assets/post_images/innodb_locks.png" alt="innodb_locks"></li><li><code>INNODB_LOCKS.lock_id</code>：锁id</li><li><code>INNODB_LOCKS.lock_mode</code>：锁模式，S锁、X锁</li><li><code>INNODB_LOCKS.lock_type</code>：锁类型，行锁、表锁</li><li><code>INNODB_LOCKS.lock_table</code>：锁定的表</li><li><code>INNODB_LOCKS.lock_index/space/page</code>：锁定的索引、spaceId、页</li><li><code>INNODB_LOCKS.lock_rec</code>：锁定行的数量</li><li><code>INNODB_LOCKS.lock_data</code>：锁定记录的主键值，注意此值为非可信值</li></ul></li><li>INNODB_LOCK_WAITS：锁等待信息记录表，记录锁、事务的等待关系，可以直白看出哪些事务发生了锁等待。<ul><li><img src="/assets/post_images/innodb_lock_waits.png" alt="innodb_lock_waits"></li><li><code>INNODB_LOCK_WAITS.requesting_trx_id</code>：申请锁资源的事务Id</li><li><code>INNODB_LOCK_WAITS.requesting_lock_id</code>：申请的锁Id</li><li><code>INNODB_LOCK_WAITS.blocking_trx_id</code>：阻塞的事务Id</li><li><code>INNODB_LOCK_WAITS.blocking_lock_id</code>：阻塞的锁Id</li><li>也就是说，从<code>lock_waits</code>表可以看出，不同事务的锁等待情况，关联<code>trx</code>和<code>locks</code>表后就可以获取详细的事务、锁信息。</li></ul></li></ul><h3 id="一致性非锁定读-VS-一致性锁定读"><a href="#一致性非锁定读-VS-一致性锁定读" class="headerlink" title="一致性非锁定读 VS 一致性锁定读"></a>一致性非锁定读 VS 一致性锁定读</h3><ul><li>一致性非锁定读（consistent nonblocking read）：通过「并发多版本控制」MVCC获取当前时间数据库中的行数据。由于获取版本机制的时间点不同，也就产生了不同的隔离级别。如<code>READ COMMITTED</code>总是读取行数据的最新版本，而<code>REPEATABLE READ</code>则是取事务开始时的数据版本。这也就造就了二者的差异，前者多次读取时可取到其他事务已提交的数据，而后者在多次读取时总是保持行为一致。</li><li>一致性锁定读（locking read）：为保证读操作中数据的一致性，需显式进行加锁来保证并发情况下的数据一致性。<ul><li><code>select ... for update</code>：在读取行上加X锁，其他事务不能加任何锁</li><li><code>select ... in share mode</code>：在读取行上加S锁，其他事务只能加S锁，如果加X锁将导致锁等待</li><li>上述两种锁定读操作时，如果其他事务为<code>非锁定读</code>操作时，是可以正常读取的（因为非锁定读操作不会加任何锁）</li><li>在进行锁定读操作时，必须显式通过<code>begin</code>、<code>start transaction</code>或<code>set autocommit=0</code>将多条SQL放在同一个事务中提交</li></ul></li></ul><h2 id="行锁中算法"><a href="#行锁中算法" class="headerlink" title="行锁中算法"></a>行锁中算法</h2><ul><li>Record Lock：对单个行记录上锁<ul><li>通过聚簇索引或二级索引查找时，会在索引上加<code>Record Lock</code></li><li>通过<code>SHOW ENGINE INNODB STATUS</code>可以看到类型如下内容：</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table xxxx</span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line">0: len 4; hex 8000000a; asc     ;;</span><br><span class="line">1: len 6; hex 00000000274f; asc     'O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><ul><li>Gap Lock：范围锁定<ul><li>按照范围锁定索引记录</li><li>例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>，为防止其他事务将值15插入到t.c1列中，无论该列中是否已有这样的值，该范围中所有现有值之间的间隙都会被锁定。</li><li><code>Gap Lock</code>是在性能和并发能力上的一种权衡方案，仅在部分事务隔离级别上采用</li><li><code>SELECT * FROM child WHERE id = 100;</code>对这类<code>id</code>具有<code>唯一索引</code>的情况，只会明确加<code>Record锁</code>，而不会加<code>Gap锁</code></li><li>而对于无索引或无唯一索引情况时，会增加<code>Gap锁</code></li></ul></li><li>Next-Key Lock：Gap+Record锁<ul><li>在唯一索引情况下会降级为RecordLock提高并发能力</li><li><code>Next-Key Lock</code>在锁定时会将下一个key区间也进行<code>Gap Lock</code>，目的是为了避免幻读的情况</li><li>所谓的<code>Next-Key</code>是指，范围区间划分是包含下一个值</li><li>如索引有10，11，13，20四个值时，可被<code>Next-Key Lock</code>的范围区间是<code>(-∞, 10]</code>, <code>(10, 11]</code>, <code>(11, 13]</code>, <code>(13, 20]</code>, <code>(20, +∞]</code>五个区间</li><li>如插入新值12后，则<code>(10, 11]</code>, <code>(11, 13]</code>裂变为<code>(10, 11]</code>, <code>(11, 12]</code>, <code>(12, 13]</code></li></ul></li></ul><p>实例1：唯一索引时，Next-Key Lock降级为Record锁，仅锁定单行记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(a <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>此时插入按唯一键<code>a</code>插入时，只会锁定单条记录，如下表：<br><img src="/assets/post_images/uniqKey_lock.png" alt="uniqKey_lock"></p><p>实例2：辅助索引（非唯一索引或主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> z(a <span class="built_in">int</span>, b <span class="built_in">int</span>, primary <span class="keyword">key</span>(a), <span class="keyword">key</span>(b));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">3</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">5</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">7</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">10</span>,<span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>执行SQL<code>select * from z where b=3 for update</code>时，锁处理为：</p><ul><li>存在两个索引，需分别进行锁定</li><li>对于<code>a</code>聚簇索引，对<code>a=5</code>进行RecordLock</li><li>对于<code>b</code>辅助索引，按<code>Next-Key</code>对区间<code>(1,3]</code>加锁</li><li>同时，InnoDB还会对下一个键值加<code>GapLock</code>，即对区间<code>(3,6]</code>加锁</li></ul><p>其他会话的下列SQL将被阻塞（锁等待）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> z <span class="keyword">where</span> a=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- a=5，是`a=5`的RecordLock锁定记录，锁等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">4</span>,<span class="number">2</span>; <span class="comment">-- b=2，在锁定区间(1,3]范围内，锁等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">6</span>,<span class="number">5</span>;  <span class="comment">-- b=5 在锁定区间(3,6]范围内，锁等待</span></span><br></pre></td></tr></table></figure><h2 id="二、锁注意问题"><a href="#二、锁注意问题" class="headerlink" title="二、锁注意问题"></a>二、锁注意问题</h2><ul><li>脏读（Dirty Read）<ul><li>详见之前文章：<a href="http://fivezh.github.io/2019/02/01/MySQL-Transaction-Isolation-Level#%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB">脏读、不可重复读、幻读</a></li></ul></li><li>不可重复读</li><li>丢失更新</li><li>幻读（Phantom Problem）<ul><li><code>Phantom Problem</code>幻读是指，同一个事务中，连续执行两次相同SQL可能出现不同的结果，第二次SQL会返回之前不存在的行。</li></ul></li></ul><h2 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h2><blockquote><p>死锁是指两个或两个以上的事务在执行过程等中，因争夺资源而造成的一种相互等待的现象。</p></blockquote><p>按照《Operating.System.Concepts 操作系统概念》一书中死锁的必要条件：</p><ul><li>互斥（Mutual exclusion，简称Mutex）<ul><li>至少有一个资源处于非共享模式，即一次只能有一个进程使用</li><li>如另一进程申请此资源，则须等待该资源释放</li></ul></li><li>占有并等待（Hold and wait）<ul><li>一个进程必须占有至少一个资源</li><li>并等待另一资源</li><li>而该资源被其他进程占用</li></ul></li><li>非抢占（No preemption）<ul><li>资源不能被抢占</li><li>即资源只能在进程完成任务后自动释放</li></ul></li><li>循环等待（Circular wait）<ul><li>一组等待进程{P0, P1…Pn-1, Pn}</li><li>P0等待资源P1占有，P1等待资源P2占有</li><li>Pn-1等待资源Pn占有，Pn等待资源P0占有</li><li>循环等待，则形成环形结构</li></ul></li></ul><blockquote><p>死锁预防、检测相关内容可详阅本书，或参考其他文献，本文不再详细展开。</p></blockquote><p>死锁发生的四个条件缺一都无法导致死锁，所以死锁恢复的方法也就是打破其中一项条件，导致死锁解除。</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ul><li><a href="https://juejin.im/post/5df61fa8f265da33e1517bdc" target="_blank" rel="noopener">Innodb锁类型</a></li><li><a href="http://hedengcheng.com/?p=844" target="_blank" rel="noopener">何登成：一个最不可思议的MySQL死锁分析</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">何登成：MySQL 加锁处理分析</a></li><li><a href="http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">MySQL加锁分析</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">MySQL InnoDB Locking</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">MySQL Phantom Rows</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL InnoDB引擎锁机制主要有「共享锁Shared Lock」、「排他锁Exclusive Lock」，另外还有「意向锁Intention Lock」，从锁的粒度上来看我们主要关注表锁（Table Lock）、行锁（Row Lock）、以及通过意向锁实现更细粒度的锁。&lt;br&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://fivezh.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引下推</title>
    <link href="http://fivezh.github.io/2020/01/19/mysql-icp/"/>
    <id>http://fivezh.github.io/2020/01/19/mysql-icp/</id>
    <published>2020-01-19T14:20:21.000Z</published>
    <updated>2020-04-13T14:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 联合索引仅支持按「最左匹配」原则使用索引。在遇到范围查询情况时，会停止利用后面的索引字段。<br><a id="more"></a><br>本文针对这一问题对联合索引原理进行说明，并引出官方对这种情况下的优化方案：ICP 索引下推机制。</p><blockquote><p>注：联合索引，又称复合索引，英文为<code>Multiple-Column Indexes</code>或<code>Composite Indexes</code></p></blockquote><h2 id="联合索引存储原理"><a href="#联合索引存储原理" class="headerlink" title="联合索引存储原理"></a>联合索引存储原理</h2><p><img src="/assets/post_images/multiColumnIndex.png" alt="multiColumnIndex"></p><p><code>index (a,b)</code>的联合索引结构如上图（出自《MySQL技术内幕-InnoDB存储引擎》），观察到每个节点中均同时包含<code>a,b</code>两个字段信息，且字段<code>a</code>全局有序，字段<code>b</code>局部有序（仅在字段<code>a</code>值相同时，字段<code>b</code>是有序的）。</p><p>查询 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx</span><br><span class="line"><span class="keyword">where</span> a&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> b=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>此时，查询过程如下：</p><ul><li>根据<code>a&gt;1</code>定位到最小值<code>(2,1)</code>，最大值为∞<ul><li>这一过程，利用<code>Index Filter</code></li></ul></li><li>此时 a 有<code>2</code>、<code>3</code>两种情况，也就是二者都有可能包含<code>b=2</code>的记录</li><li>所以只能遍历<code>a&gt;1</code>下的所有索引，才能确定<code>b=2</code>的记录项有哪些：<ul><li>这一过程因为<code>字段b局部有序，非全局有序</code>，必须遍历所有索引</li><li>所以这一操作并未充分利用到索引的特性</li><li>这也就是我们常说的，最左匹配，遇到非等值判断时匹配停止</li></ul></li><li>在未开启 ICP 的情况下，存储引擎并未利用索引上的 <code>b</code> 值进行判断。而是进行回表查询，将<code>a&gt;1</code>的所有数据读出、返回至 MySQL Server 层，由 Server 通过<code>Using where</code>根据<code>b=2</code>筛选目标记录。<ul><li>这一过程，利用<code>Table Filter</code></li></ul></li></ul><p>可见，未开启 ICP 时，<code>不能完全利用索引树及索引上存储的信息</code>，而是愚笨的通过回表取数据（b 字段数据已在索引树上存在），通过<code>Using where</code>进行数据过滤。<br>显著的改进：利用索引树上的字段信息，进行查找过滤，减少回表IO数据。</p><h2 id="索引下推-ICP-原理"><a href="#索引下推-ICP-原理" class="headerlink" title="索引下推 ICP 原理"></a>索引下推 ICP 原理</h2><p>看下官方的这个例子：<br>联合索引包含<code>zipcode, lastname, firstname</code>三个字段，查询下述 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INDEX (zipcode, lastname, firstname)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people</span><br><span class="line">  <span class="keyword">WHERE</span> zipcode=<span class="string">'95054'</span></span><br><span class="line">  <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">'%etrunia%'</span></span><br><span class="line">  <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">'%Main Street%'</span>;</span><br></pre></td></tr></table></figure><p>在未开启 ICP 优化时，按「最左匹配原则」，上述查询 SQL 仅能利用联合索引中的<code>zipcode</code> 字段，剩余<code>lastname</code>和<code>address</code>仅能回表后通过 where 过滤数据。此时通过 explain 查看执行计划，Extra 字段为<code>Using where</code>。<br>我们通常认为，这种情况下并未充分发挥索引的利用率，因为所需三字段信息在索引树上均包含全部信息，但却仅利用了索引树上的<code>zipcode</code>一个字段；其他两个字段是通过回表后，过滤的数据。<br>既然，索引树已包含全部三个字段的信息，那为何不直接通过索引树的三个字段来完成查询，避免发生回表呢？原因是，联合索引原理中只能保证局部有序，一旦有非等值查询后，后续字段无法直接通过索引树确定范围。</p><p>但是，索引树上已包含所有字段信息，是否可在回表前进行过滤，确定或减少回表数据范围呢？<br>答案是可以的，这也是 MySQL 在5.6版本后加入的功能。</p><ul><li>未开启 ICP 时的查询<br><img src="/assets/post_images/index-access-2phases.png" alt="index-access-2phases"></li><li>开启 ICP 时的查询，仅图中「红色箭头」+「对勾√」标识部分发生回表，减少 IO 操作<br><img src="/assets/post_images/index-access-with-icp.png" alt="index-access-with-icp"></li></ul><p>开启 ICP，查看执行计划时，Extra 字段会有<code>Using index condition</code>说明，表示 ICP 生效，减少了回表数据。这会改善 IO 操作数，提升处理效率。</p><h2 id="ICP-注意事项"><a href="#ICP-注意事项" class="headerlink" title="ICP 注意事项"></a>ICP 注意事项</h2><ul><li>ICP 适用于<code>range, ref, eq_ref, and ref_or_null</code>的回表操作前过滤数据</li><li>支持<code>InnoDB</code>和<code>MyISAM</code>引擎</li><li>ICP 目的是减少回表读操作数（<code>reduce the number of full-row reads</code>），从而减少 I/O 操作</li><li><code>InnoDB</code>中 ICP 仅支持二级索引，不支持聚簇索引。因<code>InnoDB</code>引擎下，聚簇索引的字段信息已全部在索引中。</li><li>指向子查询的查询条件无法利用 ICP</li><li>函数或触发器无法利用 ICP</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">MySQL: ICP</a></li><li><a href="https://mariadb.com/kb/en/index-condition-pushdown/" target="_blank" rel="noopener">MariaDB: index-condition-pushdown</a></li><li><a href="https://yq.aliyun.com/articles/27751" target="_blank" rel="noopener">【MySQL】性能优化之 Index Condition Pushdown</a></li><li><a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL 联合索引仅支持按「最左匹配」原则使用索引。在遇到范围查询情况时，会停止利用后面的索引字段。&lt;br&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://fivezh.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中-1操作负值超出unsigned阈值</title>
    <link href="http://fivezh.github.io/2020/01/04/MySQL-0-1-problems/"/>
    <id>http://fivezh.github.io/2020/01/04/MySQL-0-1-problems/</id>
    <published>2020-01-04T13:57:07.000Z</published>
    <updated>2020-01-05T12:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>背景：业务上存在逆向操作的场景下，需注意计数值在并发处理下可能的负值情况。</p><a id="more"></a><blockquote><p>逆向操作：一般是指取消类操作，如点赞对应的取消点赞。应注意取消类操作对计数值准确性的影响。</p></blockquote><p>MySQL本身字段类型支持无符号和有符号，一般情况下，当字段为<code>unsigned int</code>时，是不支持负值的。此时<code>unsigned int</code>字段写入负值时，会产生溢出，报错信息如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIGINT UNSIGNED value is out of range in 'xxxxx'</span><br></pre></td></tr></table></figure><p>本文从 MySQL 整型数值类型的范围和不同<code>sql_mode</code>模式的影响对上述问题展开讨论。</p><h2 id="一、MySQL-中整型范围和-算术运算的处理"><a href="#一、MySQL-中整型范围和-算术运算的处理" class="headerlink" title="一、MySQL 中整型范围和+/-算术运算的处理"></a>一、MySQL 中整型范围和+/-算术运算的处理</h2><h3 id="1-1-整型数值范围"><a href="#1-1-整型数值范围" class="headerlink" title="1.1 整型数值范围"></a>1.1 整型数值范围</h3><p>MySQL 支持的整型有<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>，同时不同长度的整型支持无符号<code>unsined</code>和有符号<code>signed</code>两种类型。</p><p><img src="/assets/post_images/MySQL-int.png" alt="MySQL 整型数值范围"></p><ul><li>不同类型的整型，存储字节长度不一，决定了可存储数值范围不同</li><li><code>TINYINT</code>：1字节，有符号型范围[-128, 127]，无符号型范围[0, 255]</li><li><code>INT</code>：4字节，有符号型范围[-2147483648, 2147483647]，无符号型范围[0, 4294967295]；这就是常用有符号整型<code>signed int</code>最大值为21亿多，无符号42亿多</li><li><code>BIGINT</code>：8字节，有符号[-2^63, 2^63-1]，无符号[0, 2^64-1]</li></ul><h3 id="1-2-不同算术运算符处理"><a href="#1-2-不同算术运算符处理" class="headerlink" title="1.2 不同算术运算符处理"></a>1.2 不同算术运算符处理</h3><p><img src="/assets/post_images/MySQL-arithmetic.png" alt=""></p><p>MySQL 中算术运算的结果按如下规则处理：</p><ul><li>对<code>-</code>, <code>+</code>, <code>*</code>三种运算符，如两个操作数为<code>int</code>整型，则结果按64位的<code>bigint</code>保<br>存，防止结果溢出</li><li>两个操作数为整型，若其中之一为无符号<code>unsigned int</code>，则结果为无符号；对减法操作而言，当开启<code>NO_UNSIGNED_SUBTRACTION</code>后，尽管任一操作数为无符号，但结果按有符号<code>signed</code> 保存。<ul><li>重要的，这里强制要求：两个整型操作数，只要其中一个为无符号，则结果一定为无符号</li><li>这看起来有诸多不合理，如无符号和有符号运算后结果为有符号，则必然结果溢出！比如2+-3=-1，这种情况下结果-1在保存成无符号时，必然溢出了。<em>为何 MySQL 要使用这样的处理策略呢？</em></li><li>开启<code>NO_UNSIGNED_SUBTRACTION</code>模式，也仅影响<strong>减法操作</strong>时，结果按有符号处理，来避免结果为负值的情况</li></ul></li><li>如<code>+, -, /, *, %</code>中任一操作数为实数或字符串值，结果精度保持操作数的最大精度</li><li>除法操作<code>/</code>中，结果是第一个操作数的小数位数+系统变量div_precision_increment值（缺省为4）。表达式<code>5.05 / 0.014</code>的结果的小数位数为六位（<code>360.714286</code>）</li></ul><h2 id="1-3-sql-mode-的作用"><a href="#1-3-sql-mode-的作用" class="headerlink" title="1.3 sql_mode 的作用"></a>1.3 <code>sql_mode</code> 的作用</h2><p>不同的<code>sql_mode</code>可以在会话级或全局影响 MySQL 服务器的SQL模式。不同 SQL 模式对应不同方面上 SQL 限制的严格程度不同。常见的几种模式有：</p><ul><li><code>ANSI</code>：使用标准 SQL 规范解析 SQL</li><li><code>STRICT_TRANS_TABLES</code>： 严格事务表，在插入事务表异常时，回滚整个语句</li><li><code>TRADITIONAL</code>：与传统的 SQL 数据库保持一致，在异常时直接出 error，而不是给 warning</li></ul><p>本文重点对<code>NO_UNSIGNED_SUBTRACTION</code>这种模式详细描述下。前面章节中算术运算符规则中，我们已经知道了一个重要规则：</p><ul><li><code>两个整型操作数的算术运算时，如果有一个无符号型，则结果为无符号</code></li></ul><p>但在减法操作时，两个无符号想减，结果很有可能出现有符号型。<br>如无符号型字段值为2，进行-3操作后，<code>2-3=-1</code>，在缺省配置下(结果保存为无符号型)，此时将<code>-1</code>保存为无符号型时会发生溢出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIGINT UNSIGNED value is out of range in 'xxxxx'</span><br></pre></td></tr></table></figure><p>开启<code>NO_UNSIGNED_SUBTRACTION</code>模式的作用：</p><ul><li>减法操作中，两个整型中，如果结果为负值，则结果按 signed 有符号型保存为无符号型</li><li>上述操作时，将负值结果写入 unsigned int 字段时，结果将裁剪为0值，而不会发生溢出错误或警告</li><li><strong>特别注意</strong>：此模式仅影响「减法」操作，对其他运算无影响</li></ul><p>查看和开启不同 sql_mode 的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前 sql_mode（MySQL 5.7缺省配置）</span></span><br><span class="line"><span class="keyword">select</span> @@sql_mode;</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| @@sql_mode                                                                                                            |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+<span class="comment">-----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 sql_mode 为NO_UNSIGNED_SUBTRACTION模式。</span></span><br><span class="line"><span class="comment">-- 注意应详细评估此修改，且 sql_mode 可以是多重设置的组合配置</span></span><br><span class="line"><span class="keyword">set</span> sql_mode=<span class="string">'NO_UNSIGNED_SUBTRACTION'</span>;</span><br></pre></td></tr></table></figure><h2 id="二、MySQL-中-x-1-和-x-1-区别"><a href="#二、MySQL-中-x-1-和-x-1-区别" class="headerlink" title="二、MySQL 中 x+-1 和 x-1 区别"></a>二、MySQL 中 <code>x+-1</code> 和 <code>x-1</code> 区别</h2><p>常见的，在进行逆向操作时会对字段值进行减一操作，但存在「加负一」和「减一」两种操作方式。<br>从结果上看，这两种操作方式多数时相同的。<br>在存在结果负值的情况时，<code>NO_UNSIGNED_SUBTRACTION</code>模式会影响减法操作，而对加法操作无效。<br>也就是说，如果开启<code>NO_UNSIGNED_SUBTRACTION</code>模式，「减一」操作在负值写入 unsigned int 字段时会裁剪为0，而「加负一」操作会发生字段溢出错误。</p><h3 id="2-1-业务上如何安全的进行-1操作"><a href="#2-1-业务上如何安全的进行-1操作" class="headerlink" title="2.1 业务上如何安全的进行-1操作"></a>2.1 业务上如何安全的进行-1操作</h3><ul><li>方式1：加写锁<code>select for update</code>，字段值&gt;0时，更新字段值-1</li><li>方式2：<code>update xx set x=x-1 where xxx and x&gt;0</code>，通过<code>x&gt;0</code>条件将更新效果仅作用在正值字段上。这也是利用 MySQL 本身的数据一致性特型来保证-1操作时不会出现负值</li><li>方式3：<code>update xx set x=if(changeValue&gt;=0 or x&gt;(-changeValue), x+changeValue, 0</code>，通过<code>if</code>判断条件保证结果不出现负值，成本是降低了 SQL 可读性。</li></ul><p>从业务上，入口处应做好业务校验，避免逆向操作对数据准确性的影响。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>算术运算符时，两个整型操作数，如其中有 unsigned 无符号 整型，则结果为 unsigned int</li><li>算术运算符的结果超出字段类型阈值时，则保存为对应类型的最大值<ul><li>通过<code>show warnings;</code>可查看发生的溢出警告信息<code>Warning | 1264 | Out of range value for column &#39;xxx&#39; at row</code></li></ul></li><li>MySQL的<code>NO_UNSIGNED_SUBTRACTION</code>模式，在「减法」操作时，如负值结果保存至 unsigned字段时将裁剪为0保存，最终「减法操作结果不是无符号型」</li><li>注意<code>NO_UNSIGNED_SUBTRACTION</code>模式仅影响减法操作，对<code>x=x+-1</code>这类加法操作(加负一)不生效</li></ul><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_unsigned_subtraction" target="_blank" rel="noopener">mysql/5.7/en/sql-mode.html#sqlmode_no_unsigned_subtraction</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/arithmetic-functions.html" target="_blank" rel="noopener">mysql/5.7/en/arithmetic-functions.html</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/out-of-range-and-overflow.html" target="_blank" rel="noopener">mysql/5.7/en/out-of-range-and-overflow.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;背景：业务上存在逆向操作的场景下，需注意计数值在并发处理下可能的负值情况。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://fivezh.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP中常见疏漏之处</title>
    <link href="http://fivezh.github.io/2019/10/29/php-badstyle/"/>
    <id>http://fivezh.github.io/2019/10/29/php-badstyle/</id>
    <published>2019-10-29T14:08:35.000Z</published>
    <updated>2019-10-29T14:24:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在整理 PHP 使用过程中常见容易忽略而导致错误之处，后续会持续补充更新。</p><p>同时，也是更深层次理解 PHP 实现原理、设计出发点，其中一些可发现开发者为了满足灵活扩展而专门进行的设计，善用则佳，乱用则损。</p><blockquote><p>PS：没有最好的语言，只有最合适的工具。</p></blockquote><a id="more"></a><h2 id="类名、方法名不区分大小写"><a href="#类名、方法名不区分大小写" class="headerlink" title="类名、方法名不区分大小写"></a>类名、方法名不区分大小写</h2><p>结论：不区分大小写的有如下场景，类名、函数(方法)名不区分大小写，可能要让别人耻笑了。</p><ul><li>类名</li><li>函数、方法名</li><li>魔术常量：<code>__LINE__</code>、<code>__FILE__</code>、<code>__DIR__</code>、<code>__FUNCTION__</code>、<code>__CLASS__</code>、<code>__METHOD__</code>、 <code>__NAMESPACE__</code>等</li><li>NULL、TRUE、FALSE</li><li>类型强制转换中的类型关键词</li></ul><blockquote><p>Note: Function names are case-insensitive, though it is usually good form to call functions as they appear in their declaration.</p></blockquote><p>声明：</p><ul><li>强烈建议遵从统一大小写规范，避免困扰及其他语言切换理解成本。</li><li>脚本语言以其灵活、解释执行的特性具有诸多优势，但应充分了解其弊端</li></ul><p>参考阅读：<a href="https://www.kancloud.cn/chandler/css-code-guide/50866" target="_blank" rel="noopener">PHP大小写敏感问题整理</a></p><h2 id="array-merge-中出现null的影响"><a href="#array-merge-中出现null的影响" class="headerlink" title="array_merge()中出现null的影响"></a><code>array_merge()</code>中出现<code>null</code>的影响</h2><p>结论：<code>array_merge()</code>要求每个参数必须为数组，其中任一参数非数组将导致Warning和结果为NULL<br>最佳实践：<code>array_merge()</code>前进行非空判断或强制类型转换<br>反思：弱类型语言，在处理上切记小心类型差异的影响。在PHP7之后的发展趋势上，PHP在逐步增强类型规范、约束。</p><p>代码示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="string">'foo'</span>;</span><br><span class="line">$bar = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">$res = array_merge($foo, $bar); <span class="comment">// NULL</span></span><br><span class="line">$res = array_merge(<span class="keyword">null</span>, $bar); <span class="comment">// NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最佳实践：如不确定是否数组，则强制类型转换</span></span><br><span class="line">$res = array_merge((<span class="keyword">array</span>)$foo, (<span class="keyword">array</span>)$bar); <span class="comment">// ['foo', 'a', 'b', 'c']</span></span><br><span class="line">$res = array_merge((<span class="keyword">array</span>)<span class="keyword">null</span>, (<span class="keyword">array</span>)$bar); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><h2 id="array-merge和-的区别"><a href="#array-merge和-的区别" class="headerlink" title="array_merge和+的区别"></a><code>array_merge</code>和<code>+</code>的区别</h2><p>二者相同作用：合并一个或多个数组，将一个数组附件到前一个数组之后。<br>区别：键名相同时，如何处理？（后者覆盖前者、保留前者、后者追加，一共有着3种情形）</p><ul><li><code>array_merge</code>：键名相同，字符串键名时后者覆盖前者，数字键则追加至尾部。</li><li><code>+</code>：相同键名时，仅保留第一个数组中元素，后者重复键值忽略(不区分键类型是数值or字符串)</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字索引的例子</span></span><br><span class="line"><span class="comment">// +操作符，重复数字索引：后者重复元素忽略，例子中3=&gt;a3和3=&gt;b2的索引值重复</span></span><br><span class="line">$array1 = <span class="keyword">array</span>(<span class="number">0</span> =&gt; <span class="string">'zero_a'</span>, <span class="number">2</span> =&gt; <span class="string">'two_a'</span>, <span class="number">3</span> =&gt; <span class="string">'three_a'</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="number">1</span> =&gt; <span class="string">'one_b'</span>, <span class="number">3</span> =&gt; <span class="string">'three_b'</span>, <span class="number">4</span> =&gt; <span class="string">'four_b'</span>);</span><br><span class="line">$result = $array1 + $array2;</span><br><span class="line">var_export($result);</span><br><span class="line"><span class="comment">/* 输出结果为：</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  0 =&gt; 'zero_a',</span></span><br><span class="line"><span class="comment">  2 =&gt; 'two_a',</span></span><br><span class="line"><span class="comment">  3 =&gt; 'three_a', // 重复时，+保留前者</span></span><br><span class="line"><span class="comment">  1 =&gt; 'one_b',</span></span><br><span class="line"><span class="comment">  4 =&gt; 'four_b',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$result = array_merge($array1, $array2);</span><br><span class="line">var_export($result);</span><br><span class="line"><span class="comment">/* 结果为：数字索引时，array_merge会重建索引，重复索引键值追加</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  0 =&gt; 'zero_a',</span></span><br><span class="line"><span class="comment">  1 =&gt; 'two_a',</span></span><br><span class="line"><span class="comment">  2 =&gt; 'three_a',</span></span><br><span class="line"><span class="comment">  3 =&gt; 'one_b',</span></span><br><span class="line"><span class="comment">  4 =&gt; 'three_b', // 重复时，array_merge追加，并重建索引</span></span><br><span class="line"><span class="comment">  5 =&gt; 'four_b',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数组，索引键为字符串</span></span><br><span class="line">$array1 = <span class="keyword">array</span>(<span class="string">'a'</span> =&gt; <span class="string">'zero_a'</span>, <span class="string">'c'</span> =&gt; <span class="string">'two_a'</span>, <span class="string">'d'</span> =&gt; <span class="string">'three_a'</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="string">'b'</span> =&gt; <span class="string">'one_b'</span>, <span class="string">'d'</span> =&gt; <span class="string">'three_b'</span>, <span class="string">'e'</span> =&gt; <span class="string">'four_b'</span>);</span><br><span class="line">$result = $array1 + $array2;</span><br><span class="line">var_export($result);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  'a' =&gt; 'zero_a',</span></span><br><span class="line"><span class="comment">  'c' =&gt; 'two_a',</span></span><br><span class="line"><span class="comment">  'd' =&gt; 'three_a', // 重复时，+保留前者</span></span><br><span class="line"><span class="comment">  'b' =&gt; 'one_b',</span></span><br><span class="line"><span class="comment">  'e' =&gt; 'four_b',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$result = array_merge($array1, $array2);</span><br><span class="line">var_export($result);</span><br><span class="line"><span class="comment">/* 二者执行结果一致，均为：</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  'a' =&gt; 'zero_a',</span></span><br><span class="line"><span class="comment">  'c' =&gt; 'two_a',</span></span><br><span class="line"><span class="comment">  'd' =&gt; 'three_b', // 重复时，array_merge后者覆盖前者</span></span><br><span class="line"><span class="comment">  'b' =&gt; 'one_b',</span></span><br><span class="line"><span class="comment">  'e' =&gt; 'four_b',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参考阅读：<a href="https://www.php.net/manual/zh/function.array-merge.php" target="_blank" rel="noopener">function.array-merge</a></p><h2 id="索引数组的索引值"><a href="#索引数组的索引值" class="headerlink" title="索引数组的索引值"></a>索引数组的索引值</h2><ul><li>索引可以非连续，非连续索引的影响：<code>json_encode()</code>返回结果数组 or 对象</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$foo = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">unset</span>($foo[<span class="number">1</span>]);</span><br><span class="line">var_export($foo);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  0 =&gt; 'a',</span></span><br><span class="line"><span class="comment">  2 =&gt; 'c',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>如何重建数组索引，恢复连续自增索引值<ul><li><code>array_values()</code></li><li><code>array_slice($foo, 0)</code></li><li>二者效率是否有差异？原理有和区别？</li></ul></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$foo = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">unset</span>($foo[<span class="number">1</span>]);</span><br><span class="line">$bar = array_values($foo); <span class="comment">// 方式1</span></span><br><span class="line">$bar = array_slice($foo, <span class="number">0</span>); <span class="comment">// 方式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种形式的结果均为</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array (</span></span><br><span class="line"><span class="comment">  0 =&gt; 'a',</span></span><br><span class="line"><span class="comment">  1 =&gt; 'c',</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="json-encode-返回JSON数组还是对象"><a href="#json-encode-返回JSON数组还是对象" class="headerlink" title="json_encode()返回JSON数组还是对象"></a><code>json_encode()</code>返回JSON数组还是对象</h2><p>如果 PHP 服务向前端或 Java/Golang 等强类型语言服务提供接口时，经常面临吐槽。<br>返回数据字段有时是数组，有时却是对象，对强类型语言而言就是灾难。</p><p>首先，搞清JSON 中数组Array、对象 Object 的各自定义(详见：<a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">json.org</a>)：</p><ul><li>Array：值的有序集合，以<code>[</code>开始，以<code>]</code>结束</li><li>Object：无序的<code>名称/值</code>对的集合，以<code>{</code>开始，以<code>}</code>结束</li></ul><p>PHP 中常用<code>json_encode ( mixed $value [, int $options = 0 [, int $depth = 512 ]] ) : string</code>函数进行特定类型的序列化输出。第二个参数<code>options</code>传递不同<code>JSON 常量</code>来控制序列化输出结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>json_encode()</code>总结：</p><ul><li>缺省第二参数时<ul><li>空数组时，<code>json_encode()</code>后输出<code>数组 Array</code></li><li>索引数组（键为数字），且索引键<strong>连续</strong>，<code>json_encode()</code>后输出<code>数组 Array</code></li><li>索引数组（键为数字），但索引键<strong>非连续</strong>，<code>json_encode()</code>后输出<code>对象 Object</code></li><li>关联数组（键为字符串），<code>json_encode()</code>后输出<code>对象 Object</code></li></ul></li><li>如需强制结果返回对象<ul><li>将<code>json_encode($value, JSON_FORCE_OBJECT)</code>，将结果强制返回对象</li></ul></li><li>如需强制结果返回数组<ul><li>索引数组的结果强制返回数组，重建索引保证索引连续，则<code>json_encode</code>后结果为 JSON 数组</li><li>关联数组，结果仅返回数组则丢失 key 信息，需根据数据结构明确是否合理，如坚持需要可通过<code>array_values()</code>仅取值、忽略键信息</li></ul></li></ul><p>实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空数组，返回空数组</span></span><br><span class="line">$foo = [];</span><br><span class="line">var_dump(json_encode($foo)); <span class="comment">// string(2) "[]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引连续，返回数组；如需对象，则使用JSON_FORCE_OBJECT参数</span></span><br><span class="line">$foo = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">var_dump(json_encode($foo)); <span class="comment">// string(13) "["a","b","c"]"</span></span><br><span class="line">var_dump(json_encode($foo, JSON_FORCE_OBJECT)); <span class="comment">// string(25) "&#123;"0":"a","1":"b","2":"c"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引非连续，返回对象</span></span><br><span class="line"><span class="keyword">unset</span>($foo[<span class="number">1</span>]);</span><br><span class="line">var_dump(json_encode($foo)); <span class="comment">// string(17) "&#123;"0":"a","2":"c"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联数组必然返回对象</span></span><br><span class="line">$foo = [<span class="string">'a'</span> =&gt; <span class="string">'aa'</span>, <span class="string">'b'</span> =&gt; <span class="string">'bb'</span>, <span class="string">'c'</span> =&gt; <span class="string">'cc'</span>];</span><br><span class="line">var_dump(json_encode($foo)); <span class="comment">// string(28) "&#123;"a":"aa","b":"bb","c":"cc"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联数组如必须返回数组，则丢失 key 信息</span></span><br><span class="line">var_dump(json_encode(array_values($foo))); <span class="comment">// string(16) "["aa","bb","cc"]"</span></span><br></pre></td></tr></table></figure><h2 id="array-foo-和-array-foo的区别"><a href="#array-foo-和-array-foo的区别" class="headerlink" title="array($foo)和(array)$foo的区别"></a><code>array($foo)</code>和<code>(array)$foo</code>的区别</h2><ul><li><code>array()</code>是数组声明，和[]等价</li><li><code>(array)</code>是强制类型转换</li></ul><p>在非空变量上，二者作用相当；应特别注意，当<code>$foo=null</code>时，二者区别：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$in = <span class="keyword">null</span>;</span><br><span class="line">$foo = <span class="keyword">array</span>($in); <span class="comment">// 仅包含一个null的数组，[0 =&gt; null]</span></span><br><span class="line">$bar = (<span class="keyword">array</span>)$in; <span class="comment">// 强制类型转换，空数组，[]</span></span><br></pre></td></tr></table></figure><h2 id="全角、半角字符"><a href="#全角、半角字符" class="headerlink" title="全角、半角字符"></a>全角、半角字符</h2><p>在进行字符替换时，常用来将多个空格处理成单个、或过滤空格。<br>但在全角状态下空格的识别，较为少见，但是比较容易忽略的。</p><h3 id="匹配时，容易忽略的「全角空格」"><a href="#匹配时，容易忽略的「全角空格」" class="headerlink" title="匹配时，容易忽略的「全角空格」"></a>匹配时，容易忽略的「全角空格」</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预期：替换所有空格</span></span><br><span class="line">$foo = <span class="string">"你 好，世 界   "</span>;</span><br><span class="line">$res = preg_replace(<span class="string">'/(　|\\n|\\r|\s)+/'</span>, <span class="string">''</span>, $foo);</span><br><span class="line"><span class="comment">// string(15) "你好，世界"</span></span><br><span class="line"><span class="comment">// 成功处理，将多个空格替换为单个</span></span><br><span class="line"></span><br><span class="line">$foo = <span class="string">"你　好，世　界　　"</span>;</span><br><span class="line">$res = preg_replace(<span class="string">'/(　|\\n|\\r|\s)+/'</span>, <span class="string">''</span>, $foo);</span><br><span class="line"><span class="comment">// string(27) "你　好，世　界　　"</span></span><br><span class="line"><span class="comment">// 未能处理，无法匹配和替换「全角空格」</span></span><br></pre></td></tr></table></figure><h3 id="有问题的正则遇到全角符号"><a href="#有问题的正则遇到全角符号" class="headerlink" title="有问题的正则遇到全角符号"></a>有问题的正则遇到全角符号</h3><ul><li>正则中<code>[]</code>表示多个可选的字符，但只允许单个字符，全角空格为三字符（<code>\xE3\x80\x80</code>），则会按三个分别分别匹配、替换</li><li>这样就会误替换部分中文中的字符为空，导致乱码</li><li>preg中u(PCRE_UTF8)修饰符，可支持utf8编码处理，从而支持多字节匹配问题</li><li>PS：虽然preg中的u修饰符可解决上述case，但应更加准确适用正则及其对应含义。</li></ul><blockquote><p>正则中[]的概念：[abc] A single character of: a, b or c</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，原始字符串中包含「全角空格」，正则中[]内也有此「全角空格」</span></span><br><span class="line">$foo = <span class="string">"　　一个、两个，三四个。"</span>;</span><br><span class="line">$res = preg_replace(<span class="string">'/([　\s]|\\n|\\r)+/'</span>, <span class="string">''</span>, $foo);</span><br><span class="line"><span class="comment">// 结果为：string(25) "�个�两个，三四个�"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// utf-8编码下的匹配</span></span><br><span class="line">$foo = <span class="string">"　　一个、两个，三四个。"</span>;</span><br><span class="line">$res = preg_replace(<span class="string">'/([　\s]|\\n|\\r)+/u'</span>, <span class="string">''</span>, $foo);</span><br><span class="line"><span class="comment">// string(30) "一个、两个，三四个。"</span></span><br></pre></td></tr></table></figure><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>详见另一篇文章：<a href="http://fivezh.github.io/2019/09/06/chaset-encoding-things/">PHP中编码检测</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文旨在整理 PHP 使用过程中常见容易忽略而导致错误之处，后续会持续补充更新。&lt;/p&gt;
&lt;p&gt;同时，也是更深层次理解 PHP 实现原理、设计出发点，其中一些可发现开发者为了满足灵活扩展而专门进行的设计，善用则佳，乱用则损。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：没有最好的语言，只有最合适的工具。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="http://fivezh.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>[译]Uber Go 语言代码风格指南</title>
    <link href="http://fivezh.github.io/2019/10/17/uber-go-style-guide/"/>
    <id>http://fivezh.github.io/2019/10/17/uber-go-style-guide/</id>
    <published>2019-10-17T14:12:56.000Z</published>
    <updated>2019-10-29T14:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文地址：<a href="https://github.com/uber-go/guide/blob/master/style.md" target="_blank" rel="noopener">https://github.com/uber-go/guide/blob/master/style.md</a></li><li>译文出处：<a href="https://github.com/uber-go/guide" target="_blank" rel="noopener">https://github.com/uber-go/guide</a></li><li>本文永久链接：<a href="https://github.com/gocn/translator/blob/master/2019/w38_uber_go_style_guide.md" target="_blank" rel="noopener">https://github.com/gocn/translator/blob/master/2019/w38_uber_go_style_guide.md</a></li><li>译者：<a href="https://github.com/watermelo" target="_blank" rel="noopener">咔叽咔叽</a></li><li><p>校对者：<a href="https://github.com/fivezh" target="_blank" rel="noopener">fivezh</a>，<a href="https://github.com/cvley" target="_blank" rel="noopener">cvley</a></p><a id="more"></a><blockquote><p>PS：由于博客渲染对<code>table</code>支持有缺陷，请访问 <a href="https://github.com/gocn/translator/blob/master/2019/w38_uber_go_style_guide.md" target="_blank" rel="noopener">github的本文链接</a> 查看，以确保最佳体验。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></li><li><p><a href="#introduction">介绍</a></p></li><li><a href="#guidelines">指南</a><ul><li><a href="#pointers-to-interfaces">接口的指针</a></li><li><a href="#receivers-and-interfaces">接收者和接口</a></li><li><a href="#zero-value-mutexes-are-valid">零值 Mutexes 是有效的</a></li><li><a href="#copy-slices-and-maps-at-boundaries">复制 Slice 和 Map</a></li><li><a href="#defer-to-clean-up">Defer 的使用</a></li><li><a href="#channel-size-is-one-or-none">channel 的大小是 1 或者 None</a></li><li><a href="#start-enums-at-one">枚举值从 1 开始</a></li><li><a href="#error-types">Error 类型</a></li><li><a href="#error-wrapping">Error 包装</a></li><li><a href="#handle-type-assertion-failures">处理类型断言失败</a></li><li><a href="#dont-panic">避免 Panic</a></li><li><a href="#use-gouberorgatomic">使用 go.uber.org/atomic</a></li></ul></li><li><a href="#performance">性能</a><ul><li><a href="#prefer-strconv-over-fmt">strconv 优于 fmt</a></li><li><a href="#avoid-string-to-byte-conversion">避免 string 到 byte 的转换</a></li></ul></li><li><a href="#style">代码样式</a><ul><li><a href="#group-similar-declarations">聚合相似的声明</a></li><li><a href="#import-group-ordering">包的分组导入的顺序</a></li><li><a href="#package-names">包命名</a></li><li><a href="#function-names">函数命名</a></li><li><a href="#import-aliasing">别名导入</a></li><li><a href="#function-grouping-and-ordering">函数分组和顺序</a></li><li><a href="#reduce-nesting">减少嵌套</a></li><li><a href="#unnecessary-else">不必要的 else</a></li><li><a href="#top-level-variable-declarations">顶层变量的声明</a></li><li><a href="#prefix-unexported-globals-with-_">在不可导出的全局变量前面加上 _</a></li><li><a href="#embedding-in-structs">结构体的嵌入</a></li><li><a href="#use-field-names-to-initialize-structs">使用字段名去初始化结构体</a></li><li><a href="#local-variable-declarations">局部变量声明</a></li><li><a href="#nil-is-a-valid-slice">nil 是一个有效的 slice</a></li><li><a href="#reduce-scope-of-variables">减少变量的作用域</a></li><li><a href="#avoid-naked-parameters">避免裸参数</a></li><li><a href="#use-raw-string-literals-to-avoid-escaping">使用原生字符串格式来避免转义</a></li><li><a href="#initializing-struct-references">初始化结构体</a></li><li><a href="#format-strings-outside-printf">在 Printf 之外格式化字符串</a></li><li><a href="#naming-printf-style-functions">Printf-style 函数的命名</a></li></ul></li><li><a href="#patterns">设计模式</a><ul><li><a href="#test-tables">表格驱动测试</a></li><li><a href="#functional-options">函数参数可选化</a></li></ul></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>代码风格是代码的一种约定。用风格这个词可能有点不恰当，因为这些约定涉及到的远比源码文件格式工具 gofmt 所能处理的更多。</p><p>本指南的目标是通过详细描述 Uber 在编写 Go 代码时的取舍来管理代码的这种复杂性。这些规则的存在是为了保持代码库的可管理性，同时也允许工程师更高效地使用 go 语言特性。</p><p>本指南最初由 <a href="https://github.com/prashantv" target="_blank" rel="noopener">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52" target="_blank" rel="noopener">Simon Newton</a> 为了让同事们更便捷地使用 go 语言而编写。多年来根据其他人的反馈进行了一些修改。</p><p>本文记录了 uber 在使用 go 代码中的一些习惯用法。许多都是 go 语言常见的指南，而其他的则延伸到了一些外部资料：</p><ol><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">The Go common mistakes guide</a></li></ol><p>所用的代码在运行 <code>golint</code> 和 <code>go vet</code> 之后不会有报错。建议将编辑器设置为：</p><ul><li>保存时运行 goimports</li><li>运行 <code>golint</code> 和 <code>go vet</code> 来检查错误</li></ul><p>你可以在下面的链接找到 Go tools 对一些编辑器的支持：<a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins" target="_blank" rel="noopener">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p><h2 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h2><h3 id="接口的指针"><a href="#接口的指针" class="headerlink" title="接口的指针"></a>接口的指针</h3><p>你几乎不需要指向接口的指针，应该把接口当作值传递，它的底层数据仍然可以当成一个指针。</p><p>一个接口是两个字段：</p><ol><li>指向特定类型信息的指针。你可以认为这是 “type.”。</li><li>如果存储的数据是指针，则直接存储。如果数据存储的是值，则存储指向此值的指针。</li></ol><p>如果你希望接口方法修改底层数据，则必须使用指针。</p><h3 id="接收者和接口"><a href="#接收者和接口" class="headerlink" title="接收者和接口"></a>接收者和接口</h3><p>具有值接收者的方法可以被指针和值调用。</p><p>例如,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用值只能调用 Read 方法</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会编译失败</span></span><br><span class="line"><span class="comment">//  sVals[0].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针可以调用 Read 和 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>类似的，即使方法是一个值接收者，但接口仍可以被指针类型所满足。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下不能被编译，因为 s2Val 是一个值，并且 f 没有值接收者</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure><p>Effective Go 对 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">Pointers vs. Values</a> 分析的不错.</p><h3 id="零值-Mutexes-是有效的"><a href="#零值-Mutexes-是有效的" class="headerlink" title="零值 Mutexes 是有效的"></a>零值 Mutexes 是有效的</h3><p>零值的 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的，所以你几乎不需要指向 mutex 的指针。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br></pre></td></tr></table></figure><p>如果你使用一个指针指向的结构体，mutex 可以作为一个非指针字段，或者，最好是直接嵌入这个结构体。</p><table><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span> *<span class="title">smap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;smap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><br><br><tr><br><td>为私有类型或需要实现 Mutex 接口的类型嵌入</td><br><br><td>对于导出的类型，使用私有锁。</td><br></tr><br><br></tbody></table><h3 id="复制-Slice-和-Map"><a href="#复制-Slice-和-Map" class="headerlink" title="复制 Slice 和 Map"></a>复制 Slice 和 Map</h3><p>slice 和 map 包含指向底层数据的指针，因此复制的时候需要当心。</p><h4 id="接收-Slice-和-Map-作为入参"><a href="#接收-Slice-和-Map-作为入参" class="headerlink" title="接收 Slice 和 Map 作为入参"></a>接收 Slice 和 Map 作为入参</h4><p>需要留意的是，如果你保存了作为参数接收的 map 或 slice 的引用，可以通过引用修改它。</p><table><br><thead><tr><th>Bad</th> <th>Good</th></tr></thead><br><tbody><br><tr><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did you mean to modify d1.trips?</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can now modify trips[0] without affecting d1.trips.</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br></tr><br><br></tbody><br></table><h4 id="返回-Slice-和-Map"><a href="#返回-Slice-和-Map" class="headerlink" title="返回 Slice 和 Map"></a>返回 Slice 和 Map</h4><p>类似的，当心 map 或者 slice 暴露的内部状态是可以被修改的。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 方法返回当前的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再被锁保护</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 Snapshot 是一个副本</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="Defer-的使用"><a href="#Defer-的使用" class="headerlink" title="Defer 的使用"></a>Defer 的使用</h3><p>使用 defer 去关闭文件句柄和释放锁等类似的这些资源。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个返回语句导致很容易忘记释放锁</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>defer 的开销非常小，只有在你觉得你的函数执行需要在纳秒级别的情况下才需要考虑避免使用。使用 defer 换取的可读性是值得的。这尤其适用于具有比简单内存访问更复杂的大型方法，这时其他的计算比 defer 更重要。</p><h3 id="channel-的大小是-1-或者-None"><a href="#channel-的大小是-1-或者-None" class="headerlink" title="channel 的大小是 1 或者 None"></a>channel 的大小是 1 或者 None</h3><p>channel 的大小通常应该是 1 或者是无缓冲的。默认情况下，channel 是无缓冲的且大小为 0。任何其他的大小都必须经过仔细检查。应该考虑如何确定缓冲的大小，哪些因素可以防止 channel 在负载时填满和阻塞写入，以及当这种情况发生时会造成什么样的影响。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ought to be enough for anybody!</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size 为 1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 非缓冲 channel，size 为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="枚举值从-1-开始"><a href="#枚举值从-1-开始" class="headerlink" title="枚举值从 1 开始"></a>枚举值从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个带 <code>iota</code> 的 <code>const</code> 组。由于变量的默认值为 0，因此通常应该以非零值开始枚举。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>在某些情况下，使用零值是有意义的，例如零值是想要的默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure><!-- TODO: section on String methods for enums --><h3 id="Error-类型"><a href="#Error-类型" class="headerlink" title="Error 类型"></a>Error 类型</h3><p>声明 error 有多种选项:</p><ul><li><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 声明简单静态的字符串</li><li><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 声明格式化的字符串</li><li>实现了 <code>Error()</code> 方法的自定义类型</li><li>使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 包装 error</li></ul><p>返回 error 时，可以考虑以下因素以确定最佳选择：</p><ul><li>不需要额外信息的一个简单的 error? 那么 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 就够了</li><li>客户端需要检查并处理这个 error？那么应该使用实现了 <code>Error()</code> 方法的自定义类型</li><li>是否需要传递下游函数返回的 error？那么请看 <a href="#error-wrapping">section on error wrapping</a></li><li>否则, 可以使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> </li></ul><p>如果客户端需要检查这个 error，你需要使用 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 和 var 来创建一个简单的 error。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果你有一个 error 可能需要客户端去检查，并且你想增加更多的信息（例如，它不是一个简单的静态字符串），这时候你需要使用自定义类型。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>在直接导出自定义 error 类型的时候需要小心，因为它已经是包的公共 API。最好暴露一个 matcher 函数（译者注：以下示例的 IsNotFoundError 函数）去检查 error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"foo"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- TODO: Exposing the information to callers with accessor functions. --><h3 id="Error-包装"><a href="#Error-包装" class="headerlink" title="Error 包装"></a>Error 包装</h3><p>如果调用失败，有三个主要选项用于 error 传递：</p><ul><li>如果没有额外增加的上下文并且你想维持原始 error 类型，那么返回原始 error</li><li>使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 增加上下文，以至于 error 信息提供更多的上下文，并且 <a href="https://godoc.org/github.com/pkg/errors#Cause" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Cause</code></a> 可以用来提取原始 error</li><li>如果调用者不需要检查或者处理具体的 error 例子，那么使用  <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a></li></ul><p>推荐去增加上下文信息取代描述模糊的 error，例如 “connection refused”，应该返回例如 “failed to<br>call service foo: connection refused” 这样更有用的 error。</p><p>请参考 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>.</p><h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p>简单的返回值形式的<a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">类型断言</a>在断言不正确的类型时将会 panic。因此，需要使用 “, ok” 的常用方式。 </p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// handle the error gracefully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><!-- TODO: There are a few situations where the single assignment form isfine. --><h3 id="避免-Panic"><a href="#避免-Panic" class="headerlink" title="避免 Panic"></a>避免 Panic</h3><p>生产环境跑的代码必须避免 panic。它是导致 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">级联故障</a> 的主要原因。如果一个 error 产生了，函数必须返回 error 并且允许调用者决定是否处理它。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  foo(os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := foo(os.Args[<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>panic/recover 不是 error 处理策略。程序在发生不可恢复的时候会产生 panic，例如对 nil 进行解引用。一个例外是在程序初始化的时候：在程序启动时那些可能终止程序的问题会造成 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure><p>甚至在测试用例中，更偏向于使用 <code>t.Fatal</code> 或者 <code>t.FailNow</code> 解决 panic 确保这个测试被标记为失败。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><!-- TODO: Explain how to use _test packages. --><h3 id="使用-go-uber-org-atomic"><a href="#使用-go-uber-org-atomic" class="headerlink" title="使用 go.uber.org/atomic"></a>使用 go.uber.org/atomic</h3><p>使用 <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">sync/atomic</a> 对原生类型（例如，<code>int32</code>，<code>int64</code>）进行原子操作的时候，很容易在读取或者修改变量的时候忘记使用原子操作。</p><p><a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 通过隐藏底层类型使得这些操作是类型安全的。此外，它还包含一个比较方便的 <code>atomic.Bool</code> 类型。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>指定的性能指南仅适用于 <strong>hot path</strong>（译者注：hot path 指频繁执行的代码路径）</p><h3 id="strconv-优于-fmt"><a href="#strconv-优于-fmt" class="headerlink" title="strconv 优于 fmt"></a>strconv 优于 fmt</h3><p>对基本数据类型的字符串表示的转换，<code>strconv</code> 比<br><code>fmt</code> 速度快。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = ...</span><br><span class="line">s := fmt.Sprint(i)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = ...</span><br><span class="line">s := strconv.Itoa(i)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免-string-到-byte-的转换"><a href="#避免-string-到-byte-的转换" class="headerlink" title="避免 string 到 byte 的转换"></a>避免 string 到 byte 的转换</h3><p>不要重复用固定 string 创建 byte slice。相反，执行一次转换后保存结果，避免重复转换。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="聚合相似的声明"><a href="#聚合相似的声明" class="headerlink" title="聚合相似的声明"></a>聚合相似的声明</h3><p>Go 支持分组声明。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>也能应用于常量，变量和类型的声明。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>只需要对相关类型进行分组声明。不相关的不需要进行分组声明。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  ENV_VAR = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV_VAR = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>分组不受限制。例如，我们可以在函数内部使用它们。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">    green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="包的分组导入的顺序"><a href="#包的分组导入的顺序" class="headerlink" title="包的分组导入的顺序"></a>包的分组导入的顺序</h3><p>有两个导入分组：</p><ul><li>标准库</li><li>其他库</li></ul><p>这是默认情况下 goimports 应用的分组。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h3><p>当给包命名的时候，可以参考以下方法，</p><ul><li>都是小写字母。没有大写字母或者下划线</li><li>在大多数场景下没必要重命名包</li><li>简明扼要。记住，每次调用时都会通过名称来识别。</li><li>不要复数。例如，要使用 <code>net/url</code>,  不要使用 <code>net/urls</code></li><li>不要使用 “common”, “util”, “shared”, “lib” 诸如此类的命名。这种方式不太好，无法从名字中获取有效信息。</li></ul><p>也可以参考 <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a> 和 <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Style guideline for Go packages</a>.</p><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>我们遵循 Go 社区的习惯方法，使用<a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">驼峰法命名函数</a>。测试函数是个例外，包含下划线是为了分组相关的测试用例。例如，<code>TestMyFunction_WhatIsBeingTested</code>。</p><h3 id="别名导入"><a href="#别名导入" class="headerlink" title="别名导入"></a>别名导入</h3><p>如果包名和导入路径的最后一个元素不匹配，则要使用别名导入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在大部分场景下，除非导入的包有直接的冲突，应该避免使用别名导入。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="函数分组和顺序"><a href="#函数分组和顺序" class="headerlink" title="函数分组和顺序"></a>函数分组和顺序</h3><ul><li>函数应该按大致的调用顺序排序</li><li>同一个文件的函数应该按接收者分组</li></ul><p>因此，导出的函数应该在 <code>struct</code>，<code>const</code>，<code>var</code> 定义之后。</p><p><code>newXYZ()</code>/<code>NewXYZ()</code> 应该在类型定义之后，并且在接收者的其余的方法之前出现。 </p><p>因为函数是按接收者分组的，所以普通的函数应该快到文件末尾了。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n <span class="keyword">int</span>[])</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n <span class="keyword">int</span>[])</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>在可能的情况下，代码应该通过先处理 错误情况/特殊条件 并提前返回或继续循环来减少嵌套。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置同样的变量，则可以用单个 if 替换它。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="顶层变量的声明"><a href="#顶层变量的声明" class="headerlink" title="顶层变量的声明"></a>顶层变量的声明</h3><p>在顶层，使用标准的 <code>var</code> 关键字。不要指定类型，除非它与表达式的类型不同。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// F 已经声明了返回一个 string，我们不需要再次指定类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果表达式的类型与请求的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F 返回了一个 myError 类型的对象，但是我们想要 error</span></span><br></pre></td></tr></table></figure><h3 id="在不可导出的全局变量前面加上"><a href="#在不可导出的全局变量前面加上" class="headerlink" title="在不可导出的全局变量前面加上 _"></a>在不可导出的全局变量前面加上 _</h3><p>在不可导出的顶层 <code>var</code> 和 <code>const</code> 的前面加上 <code>_</code>，以便明确它们是全局符号。</p><p>特例：不可导出的 error 值前面应该加上 <code>err</code> 前缀。</p><p>理论依据：顶层变量和常量有一个包作用域。使用通用的名称很容易在不同的文件中意外地使用错误的值</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们将 Bar() 的第一行删除，将不会看到编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="结构体的嵌入"><a href="#结构体的嵌入" class="headerlink" title="结构体的嵌入"></a>结构体的嵌入</h3><p>嵌入的类型（例如 mutex）应该在结构体字段的头部，并且在嵌入字段和常规字段间保留一个空行来隔离。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="使用字段名去初始化结构体"><a href="#使用字段名去初始化结构体" class="headerlink" title="使用字段名去初始化结构体"></a>使用字段名去初始化结构体</h3><p>当初始化结构体的时候应该指定字段名称，现在在使用 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 的情况下是强制性的。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>特例：当有 3 个或更少的字段时，可以在测试表中省略字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量声明"><a href="#局部变量声明" class="headerlink" title="局部变量声明"></a>局部变量声明</h3><p>短变量声明（<code>:=</code>）应该被使用在有明确值的情况下。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>然而，使用 <code>var</code> 关键字在某些情况下会让默认值更清晰，<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">声明空 Slice</a>，例如</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h3><p><code>nil</code> 是一个长度为 0 的 slice。意思是，</p><ul><li><p>使用 <code>nil</code> 来替代长度为 0 的 slice 返回</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li><li><p>检查一个空 slice，应该使用 <code>len(s) == 0</code>，而不是 <code>nil</code>。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li><li><p>The zero value (a slice declared with <code>var</code>) is usable immediately without<br><code>make()</code>.</p></li><li><p>零值（通过 <code>var</code> 声明的 slice）是立马可用的，并不需要 <code>make()</code> 。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li></ul><h3 id="减少变量的作用域"><a href="#减少变量的作用域" class="headerlink" title="减少变量的作用域"></a>减少变量的作用域</h3><p>在没有 <a href="#reduce-nesting">减少嵌套</a> 相冲突的情况下，尽量减少变量的作用域。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果在 if 之外需要函数调用的结果，则不要缩小作用域。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(<span class="string">"f"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  _, err = io.WriteString(f, <span class="string">"data"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"f"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := io.WriteString(f, <span class="string">"data"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f.Close()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免裸参数"><a href="#避免裸参数" class="headerlink" title="避免裸参数"></a>避免裸参数</h3><p>函数调用中的裸参数不利于可读性。当参数名的含义不明显时，添加 C 语言风格的注释（<code>/*…*/</code>）。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>更好的方法是，用自定义类型替换裸 <code>bool</code> 类型，以获得更可读的和类型安全的代码。这使得该参数未来的状态是可以增加的，不仅仅是两种（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// 可能未来我们将有一个 StatusInProgress 的状态</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用原生字符串格式来避免转义"><a href="#使用原生字符串格式来避免转义" class="headerlink" title="使用原生字符串格式来避免转义"></a>使用原生字符串格式来避免转义</h3><p>Go 支持 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原生字符串格式</a> ，它可以跨越多行并包含引号。使用这些来避免手动转义的字符串，因为手动转义的可读性很差。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><p>在初始化结构体的时候使用 <code>&amp;T{}</code> 替代 <code>new(T)</code>，以至于结构体初始化是一致的。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不一致</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="在-Printf-之外格式化字符串"><a href="#在-Printf-之外格式化字符串" class="headerlink" title="在 Printf 之外格式化字符串"></a>在 Printf 之外格式化字符串</h3><p>如果你在 <code>Printf</code> 风格函数的外面声明一个格式化字符串，请使用 <code>const</code> 值。</p><p>这有助于 <code>go vet</code> 对格式化字符串执行静态分析。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="Printf-style-函数的命名"><a href="#Printf-style-函数的命名" class="headerlink" title="Printf-style 函数的命名"></a>Printf-style 函数的命名</h3><p>当你声明一个 <code>Printf</code> 风格的函数，请确认 <code>go vet</code> 能够发现并检查这个格式化字符串。</p><p>这意味着你应该尽可能为 <code>Printf</code> 风格的函数名进行预定义 。<code>go vet</code> 默认会检查它们。查看 <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf family</a> 获取更多信息。 </p><p>如果预定义函数名不可取，请用 f 作为名字的后缀即 <code>wrapf</code>，而不是 <code>wrap</code>。<code>go vet</code> 可以检查特定的 <code>printf</code> 风格的名称，但它们必须以 f 结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure><p>请参考 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h3><p>当核心测试逻辑重复的时候，用 <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 做表格驱动测试（译者注：table-driven tests 即 TDT 表格驱动方法）可以避免重复的代码。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>表格驱动测试使向错误消息添加上下文、减少重复逻辑和添加新测试用例变得更容易。</p><p>我们遵循这样一种约定，即结构体 slice 被称为 <code>tests</code>，每个测试用例被称为 <code>tt</code>。此外，我们鼓励使用 <code>give</code> 和 <code>want</code> 前缀解释每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数可选化"><a href="#函数参数可选化" class="headerlink" title="函数参数可选化"></a>函数参数可选化</h3><p>函数参数可选化（functional options）是一种模式，在这种模式中，你可以声明一个不确定的 <code>Option</code> 类型，该类型在内部结构体中记录信息。函数接收可选化的参数，并根据在结构体上记录的参数信息进行操作</p><p>将此模式用于构造函数和其他需要扩展的公共 API 中的可选参数，特别是在这些函数上已经有三个或更多参数的情况下。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">  caching <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout 和 caching 必须要提供，哪怕用户想使用默认值</span></span><br><span class="line"></span><br><span class="line">db.Connect(addr, db.DefaultTimeout, db.DefaultCaching)</span><br><span class="line">db.Connect(addr, newTimeout, db.DefaultCaching)</span><br><span class="line">db.Connect(addr, db.DefaultTimeout, <span class="literal">false</span> <span class="comment">/* caching */</span>)</span><br><span class="line">db.Connect(addr, newTimeout, <span class="literal">false</span> <span class="comment">/* caching */</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  timeout time.Duration</span><br><span class="line">  caching <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 重写 Connect.</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> optionFunc <span class="function"><span class="keyword">func</span><span class="params">(*options)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f optionFunc)</span> <span class="title">apply</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">  f(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(t time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optionFunc(<span class="function"><span class="keyword">func</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">    o.timeout = t</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCaching</span><span class="params">(cache <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optionFunc(<span class="function"><span class="keyword">func</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">    o.caching = cache</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect 创建一个 connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    timeout: defaultTimeout,</span><br><span class="line">    caching: defaultCaching,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Options 只在需要的时候提供</span></span><br><span class="line"></span><br><span class="line">db.Connect(addr)</span><br><span class="line">db.Connect(addr, db.WithTimeout(newTimeout))</span><br><span class="line">db.Connect(addr, db.WithCaching(<span class="literal">false</span>))</span><br><span class="line">db.Connect(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCaching(<span class="literal">false</span>),</span><br><span class="line">  db.WithTimeout(newTimeout),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>请参考,</p><ul><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://github.com/uber-go/guide/blob/master/style.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/uber-go/guide/blob/master/style.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出处：&lt;a href=&quot;https://github.com/uber-go/guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/uber-go/guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/gocn/translator/blob/master/2019/w38_uber_go_style_guide.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gocn/translator/blob/master/2019/w38_uber_go_style_guide.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/watermelo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咔叽咔叽&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;校对者：&lt;a href=&quot;https://github.com/fivezh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fivezh&lt;/a&gt;，&lt;a href=&quot;https://github.com/cvley&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cvley&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[译]Go compiler intrinsics Go编译器内建函数</title>
    <link href="http://fivezh.github.io/2019/09/09/go-compiler-intrinsics/"/>
    <id>http://fivezh.github.io/2019/09/09/go-compiler-intrinsics/</id>
    <published>2019-09-09T10:44:03.000Z</published>
    <updated>2019-09-18T10:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文地址：<a href="https://dave.cheney.net/2019/08/20/go-compiler-intrinsics" target="_blank" rel="noopener">https://dave.cheney.net/2019/08/20/go-compiler-intrinsics</a></li><li>原文作者：<a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a></li><li>译文出处：<a href="https://dave.cheney.net/" target="_blank" rel="noopener">https://dave.cheney.net/</a></li><li>本文永久链接：<a href="https://github.com/gocn/translator/blob/master/2019/w35_go_compiler_intrinsics.md" target="_blank" rel="noopener">https://github.com/gocn/translator/blob/master/2019/w35_go_compiler_intrinsics.md</a></li><li>译者：<a href="https://github.com/fivezh" target="_blank" rel="noopener">fivezh</a>、<a href="https://github.com/watermelo" target="_blank" rel="noopener">咔叽咔叽</a></li><li>校对者：<a href="https://github.com/watermelo" target="_blank" rel="noopener">咔叽咔叽</a><a id="more"></a></li></ul><p>如有需要，Go 允许使用者通过汇来编写函数。这被称作 <em>stub</em> 或 <em>forward</em> 声明.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> asm</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add returns the sum of a and b.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int64</span>, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span></span><br></pre></td></tr></table></figure><p>这里，我们声明了 <code>Add</code> 函数，其接受 2 个 <code>int64</code> 类型入参，并返回二者之和。<code>Add</code> 函数相较于 Go 常见形式的函数声明，缺少了函数体部分。</p><p>如果我们尝试编译这个包时，编译器自然是会给出警告信息的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> go build</span></span><br><span class="line">examples/asm</span><br><span class="line">./decl.go:4:6: missing function body</span><br></pre></td></tr></table></figure><p>为了满足编译器要求，我们通过汇编的方式为 <code>Add</code> 提供函数体，这里可以在同一个包下新增 <code>.s</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT ·Add(SB),$0-24</span><br><span class="line">        MOVQ a+0(FP), AX</span><br><span class="line">        ADDQ b+8(FP), AX</span><br><span class="line">        MOVQ AX, ret+16(FP)</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>现在我们可以进行 <code>build</code> ，<code>test</code> 操作，像普通的 Go 代码一样使用 <code>Add</code> 函数。但是，有一个问题，汇编函数无法被内联。</p><p>这一直是被 Go 开发者所抱怨的，他们希望通过汇编来提高性能或访问未被语言暴露的操作。比如说，矢量指令，原子指令等等。如果没有内联汇编函数的能力，在 Go 中编写这些函数会产生相对较大的负担。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Result <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddNative</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r <span class="keyword">int64</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">                r = <span class="keyword">int64</span>(i) + <span class="keyword">int64</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAddAsm</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r <span class="keyword">int64</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">                r = Add(<span class="keyword">int64</span>(i), <span class="keyword">int64</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        Result = r</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkAddNative-8  1000000000        0.300 ns/op</span><br><span class="line">BenchmarkAddAsm-8     606165915         1.93 ns/op</span><br></pre></td></tr></table></figure><blockquote><p>译者注：Go 原生的方式，性能优于汇编方式，这也是本文所关注的 Go 内建函数的优化。</p></blockquote><p>多年来，已经有多种提案来支持内联汇编的语法，比如类似与 gcc 的 <code>asm(...)</code> 指令。但没有任何一个提案被 Go 团队接受。相反，Go 添加了一种内建函数 <em>intrinsic functions</em> 。</p><blockquote><p>注 1：内建函数 可能不是他们的正式名称，但是这个词在编译器及其测试中是很常用的。</p><p>译者注：参见维基百科<a href="https://en.wikipedia.org/wiki/Intrinsic_function" target="_blank" rel="noopener">Intrinsic function</a></p></blockquote><p>内建函数<em>intrinsic function</em>是使用常规 Go 编写的 Go 代码。这些函数在 Go 编译器中是已知的，它包含可在编译期间进行替换的待替换元素。从 Go 1.13 开始，编译器支持的包有：</p><ul><li><code>math/bits</code></li><li><code>sync/atomic</code></li></ul><p>这些包中的函数具有巴洛克式签名（译者注：形容繁琐且富于变化的签名形式），但在你的系统架构支持更有效的执行方式时，编译器可以使用相近的原生指令来进行透明的替换函数调用。</p><p>对于本文的其余部分，我们将研究 Go 编译器使用内建函数 <em>intrinsic function</em> 生成更高效代码的两种不同方式。</p><h2 id="Ones-count-位为-1-的计数"><a href="#Ones-count-位为-1-的计数" class="headerlink" title="Ones count 位为 1 的计数"></a>Ones count 位为 1 的计数</h2><p>一个词中位为 <code>1</code> 的数量，这类计数是一种重要的加密和压缩原语。因为这是一项基础且重要的操作，所以大多数现代 CPU 都提供了原生硬件实现。</p><p><code>math/bits</code> 包通过 <code>OnesCount</code> 系列函数提供了对该操作的支持。 各种 <code>OnesCount</code> 函数被编译器识别，并且取决于 CPU 架构和 Go 的版本，将被本机硬件指令替换。</p><p>要了解这有多么有效，我们可以比较三种不同的计数实现。 第一个是 Kernighan 在《The C Programming Language 2nd Ed, 1998》书中提到的算法。</p><blockquote><p>注 2：Kernighan 《The C Programming Language 2nd Ed, 1998》，C 语言 Bible</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kernighan</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= (x - <span class="number">1</span>) &#123;</span><br><span class="line">                count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法最大循环次数由数字本身的位数决定; 数字具有的位数越多，则它的循环次数越多。</p><p>第二个算法会令黑客们会心一笑，来自<a href="https://github.com/golang/go/issues/14813" target="_blank" rel="noopener">issue 14813</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hackersdelight</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">const</span> m1 = <span class="number">0x5555555555555555</span></span><br><span class="line">        <span class="keyword">const</span> m2 = <span class="number">0x3333333333333333</span></span><br><span class="line">        <span class="keyword">const</span> m4 = <span class="number">0x0f0f0f0f0f0f0f0f</span></span><br><span class="line">        <span class="keyword">const</span> h01 = <span class="number">0x0101010101010101</span></span><br><span class="line"></span><br><span class="line">        x -= (x &gt;&gt; <span class="number">1</span>) &amp; m1</span><br><span class="line">        x = (x &amp; m2) + ((x &gt;&gt; <span class="number">2</span>) &amp; m2)</span><br><span class="line">        x = (x + (x &gt;&gt; <span class="number">4</span>)) &amp; m4</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>((x * h01) &gt;&gt; <span class="number">56</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果输入是一个常量（如果编译器可以在编译时间找出答案的话，整个事情会优化掉），这个版本算法中很多比特位都会在恒定时间内运行并且非常好地优化。</p><p>让我们根据 <code>math/bits.OnesCount64</code> 对这些实现进行基准测试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkKernighan</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">                r = kernighan(<span class="keyword">uint64</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        Result = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopcnt</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">                r = hackersdelight(<span class="keyword">uint64</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        Result = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMathBitsOnesCount64</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">                r = bits.OnesCount64(<span class="keyword">uint64</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保持公平，我们在为每个被测函数提供相同的输入：从零到 <code>b.N</code> 的整数序列。这对于 Kernighan 的方法更为公平，因为它的运行时间随着入参的位数而逐渐增加。</p><blockquote><p>注 3：作为加分小作业，可以尝试将 <code>0xdeadbeefdeadbeef</code> 传递给每个被测试的函数，看看运行结果如何。</p></blockquote><p>来看下测试结果：<code>go test -bench=. -run=none</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkKernighan-8        100000000       11.2 ns/op</span><br><span class="line">BenchmarkPopcnt-8           618312062       2.02 ns/op</span><br><span class="line">BenchmarkMathBitsOnesCount64-8  1000000000  0.565 ns/op</span><br></pre></td></tr></table></figure><p><code>math/bits.OnesCount64</code> 以近 4 倍的速度优势胜出，但是这真的是因为使用硬件指令，还是因为编译器在代码优化方面做得更好呢？让我们来检查下汇编的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">% go test -c</span><br><span class="line">% go tool objdump -s MathBitsOnesCount popcnt-intrinsic.test</span><br><span class="line">TEXT examples/popcnt-intrinsic.BenchmarkMathBitsOnesCount64(SB) </span><br><span class="line">/examples/popcnt-intrinsic/popcnt_test.go</span><br><span class="line">   popcnt_test.go:45     0x10f8610    65488b0c2530000000  MOVQ GS:0x30, CX</span><br><span class="line">   popcnt_test.go:45     0x10f8619    483b6110            CMPQ 0x10(CX), SP</span><br><span class="line">   popcnt_test.go:45     0x10f861d    7668                JBE 0x10f8687</span><br><span class="line">   popcnt_test.go:45     0x10f861f    4883ec20            SUBQ $0x20, SP</span><br><span class="line">   popcnt_test.go:45     0x10f8623    48896c2418          MOVQ BP, 0x18(SP)</span><br><span class="line">   popcnt_test.go:45     0x10f8628    488d6c2418          LEAQ 0x18(SP), BP</span><br><span class="line">   popcnt_test.go:47     0x10f862d    488b442428          MOVQ 0x28(SP), AX</span><br><span class="line">   popcnt_test.go:47     0x10f8632    31c9                XORL CX, CX</span><br><span class="line">   popcnt_test.go:47     0x10f8634    31d2                XORL DX, DX</span><br><span class="line">   popcnt_test.go:47     0x10f8636    eb03                JMP 0x10f863b</span><br><span class="line">   popcnt_test.go:47     0x10f8638    48ffc1              INCQ CX</span><br><span class="line">   popcnt_test.go:47     0x10f863b    48398808010000      CMPQ CX, 0x108(AX)</span><br><span class="line">   popcnt_test.go:47     0x10f8642    7e32                JLE 0x10f8676</span><br><span class="line">   popcnt_test.go:48     0x10f8644    803d29d5150000      CMPB $0x0, runtime.x86HasPOPCNT(SB)</span><br><span class="line">   popcnt_test.go:48     0x10f864b    740a                JE 0x10f8657</span><br><span class="line">   popcnt_test.go:48     0x10f864d    4831d2              XORQ DX, DX</span><br><span class="line">   popcnt_test.go:48     0x10f8650    f3480fb8d1          POPCNT CX, DX // math/bits.OnesCount64</span><br><span class="line">   popcnt_test.go:48     0x10f8655    ebe1                JMP 0x10f8638</span><br><span class="line">   popcnt_test.go:47     0x10f8657    48894c2410          MOVQ CX, 0x10(SP)</span><br><span class="line">   popcnt_test.go:48     0x10f865c    48890c24            MOVQ CX, 0(SP)</span><br><span class="line">   popcnt_test.go:48     0x10f8660    e87b28f8ff          CALL math/bits.OnesCount64(SB)</span><br><span class="line">   popcnt_test.go:48     0x10f8665    488b542408          MOVQ 0x8(SP), DX</span><br><span class="line">   popcnt_test.go:47     0x10f866a    488b442428          MOVQ 0x28(SP), AX</span><br><span class="line">   popcnt_test.go:47     0x10f866f    488b4c2410          MOVQ 0x10(SP), CX</span><br><span class="line">   popcnt_test.go:48     0x10f8674    ebc2                JMP 0x10f8638</span><br><span class="line">   popcnt_test.go:50     0x10f8676    48891563d51500      MOVQ DX, examples/</span><br><span class="line">   popcnt-intrinsic.Result(SB)</span><br><span class="line">   popcnt_test.go:51     0x10f867d    488b6c2418          MOVQ 0x18(SP), BP</span><br><span class="line">   popcnt_test.go:51     0x10f8682    4883c420            ADDQ $0x20, SP</span><br><span class="line">   popcnt_test.go:51     0x10f8686    c3                  RET</span><br><span class="line">   popcnt_test.go:45     0x10f8687    e884eef5ff          CALL runtime.morestack_noctxt(SB)</span><br><span class="line">   popcnt_test.go:45     0x10f868c    eb82                JMP examples/</span><br><span class="line">   popcnt-intrinsic.BenchmarkMathBitsOnesCount64(SB)</span><br><span class="line">   :-1                   0x10f868e    cc                  INT $0x3</span><br><span class="line">   :-1                   0x10f868f    cc                  INT $0x3</span><br></pre></td></tr></table></figure><p>这里输出了很多内容，但关键的内容是第 48 行（取自 <code>_test.go</code> 文件的源代码），程序确实使用了我们期望的 x86 <code>POPCNT</code> 指令。事实证明这比操作位运算更快。</p><p>有趣的是比较 <code>POPCNT</code> 之前的两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMPB $0x0, runtime.x86HasPOPCNT(SB)</span><br></pre></td></tr></table></figure><p>并非所有的英特尔 CPU 都支持 <code>POPCNT</code> ，如果 CPU 支持此指令，那么 Go 运行时在启动时，就会将此结果存储在 <code>runtime.x86HasPOPCNT</code> 中。这样每次进行基准测试循环时，程序通过检查 <em>CPU 是否支持 POPCNT</em> ，然后再发出 <code>POPCNT</code> 请求。</p><p><code>runtime.x86HasPOPCNT</code> 的值在程序执行期间不会变化，因此检查结果是高度可预测的，这使得这种检查的成本相对低廉。</p><h2 id="Atomic-counter-原子计数器"><a href="#Atomic-counter-原子计数器" class="headerlink" title="Atomic counter 原子计数器"></a>Atomic counter 原子计数器</h2><p>除了生成更高效的代码之外，内建函数<em>intrinsic functions</em>只是常规的 Go 代码，内联规则（包括中间堆栈内联）同样适用于它们。</p><p>这是一个原子计数器类型的例子。它有类型的方法，深层的方法调用，多个包等情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">         <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> counter <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c counter)</span> <span class="title">get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> atomic.LoadUint64((<span class="keyword">uint64</span>)(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c counter)</span> <span class="title">inc</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.AddUint64((<span class="keyword">uint64</span>)(c), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c counter)</span> <span class="title">reset</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.SwapUint64((<span class="keyword">uint64</span>)(c), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">        c.inc()</span><br><span class="line">        c.get()</span><br><span class="line">        <span class="keyword">return</span> c.reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>译者注：原文代码有误无法编译，代码进行了部分修改，<code>(uint64)(c)</code> 修改为 <code>(*uint64)(&amp;c)</code></p></blockquote><p>你或许会认为上述这种操作会产生很多开销，这是可以理解的。但由于内联和编译器内建函数之间的交互，这些代码在大多数平台上会转换为很高效的原生代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TEXT main.f(SB) examples/counter/counter.go</span><br><span class="line">   counter.go:23   0x10512e0   90                      NOPL</span><br><span class="line">   counter.go:29   0x10512e1   b801000000              MOVL $0x1, AX</span><br><span class="line">   counter.go:13   0x10512e6   488d0d0bca0800          LEAQ main.c(SB), CX</span><br><span class="line">   counter.go:13   0x10512ed   f0480fc101              LOCK XADDQ AX, 0(CX) // c.inc</span><br><span class="line">   counter.go:24   0x10512f2   90                      NOPL</span><br><span class="line">   counter.go:10   0x10512f3   488b05fec90800          MOVQ main.c(SB), AX // c.get</span><br><span class="line">   counter.go:25   0x10512fa   90                      NOPL</span><br><span class="line">   counter.go:16   0x10512fb   31c0                    XORL AX, AX</span><br><span class="line">   counter.go:16   0x10512fd   488701                  XCHGQ AX, 0(CX) // c.reset</span><br><span class="line">   counter.go:16   0x1051300               c3                      RET</span><br></pre></td></tr></table></figure><p>下面我们逐一解释下。第一个操作，<code>counter.go:13</code> 是 <code>c.inc</code> 一个 <code>LOCK</code> 和 <code>XADDQ</code> 指令，这在 x86 上是一个原子性的增量。第二个，<code>counter.go:10</code> 是 <code>c.get</code> ，由于 x86 强大的内存一致性模型，它是内存级的常规操作。最后一个操作，<code>counter.go:16</code> ，<code>c.reset</code> 是 <code>CX</code> 中地址与 <code>AX</code> 的原子交换，而 <code>AX</code> 在前一行被归零(<code>XORL AX, AX</code>，按位异或，相当于清零)。这将 <code>AX</code> 中的值（零）放入存储在 <code>CX</code> 中的地址中，而先前存储在 <code>(CX)</code> 的值被丢弃。</p><h2 id="Conclusion-总结"><a href="#Conclusion-总结" class="headerlink" title="Conclusion 总结"></a>Conclusion 总结</h2><p>内建函数是一种简洁的解决方案，它使 Go 程序员可以进行低层架构的操作，而无需扩展语言规范。如果某个体系结构没有特定的 <code>sync/atomic</code> 原语（比如某些 ARM 的变体）或者 <code>math/bits</code> 操作，那么编译器会隐式地降级为用纯 Go 编写的操作。</p><h2 id="Related-posts-相关文章"><a href="#Related-posts-相关文章" class="headerlink" title="Related posts 相关文章"></a>Related posts 相关文章</h2><ol><li><a href="https://dave.cheney.net/2012/10/07/notes-on-exploring-the-compiler-flags-in-the-go-compiler-suite" title="Notes on exploring the compiler flags in the Go compiler suite" target="_blank" rel="noopener">Notes on exploring the compiler flags in the Go compiler suite</a></li><li><a href="https://dave.cheney.net/2015/10/09/padding-is-hard" title="Padding is hard" target="_blank" rel="noopener">Padding is hard</a></li><li><a href="https://dave.cheney.net/2016/03/19/should-methods-be-declared-on-t-or-t" title="Should methods be declared on T or *T" target="_blank" rel="noopener">Should methods be declared on T or *T</a></li><li><a href="https://dave.cheney.net/2015/11/18/wednesday-pop-quiz-spot-the-race" title="Wednesday pop quiz: spot the race" target="_blank" rel="noopener">Wednesday pop quiz: spot the race</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://dave.cheney.net/2019/08/20/go-compiler-intrinsics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dave.cheney.net/2019/08/20/go-compiler-intrinsics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://dave.cheney.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dave Cheney&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出处：&lt;a href=&quot;https://dave.cheney.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dave.cheney.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/gocn/translator/blob/master/2019/w35_go_compiler_intrinsics.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gocn/translator/blob/master/2019/w35_go_compiler_intrinsics.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/fivezh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fivezh&lt;/a&gt;、&lt;a href=&quot;https://github.com/watermelo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咔叽咔叽&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/watermelo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咔叽咔叽&lt;/a&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>PHP中编码检测</title>
    <link href="http://fivezh.github.io/2019/09/06/chaset-encoding-things/"/>
    <id>http://fivezh.github.io/2019/09/06/chaset-encoding-things/</id>
    <published>2019-09-06T07:01:07.000Z</published>
    <updated>2019-09-18T10:48:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>背景：</p><ul><li>编码问题在Python同学眼中应该是老生常谈的，本文谈下PHP中常见的编码相关检测方法及局限</li><li>数据在写入时决定了编码形式，而由于历史变更可能存在历史数据中写入编码不同</li><li>编码检测的目的：检测数据的编码形式，正确解码及界面展示</li></ul><a id="more"></a><h2 id="PHP中不同编码检测方法"><a href="#PHP中不同编码检测方法" class="headerlink" title="PHP中不同编码检测方法"></a>PHP中不同编码检测方法</h2><h3 id="mb-detect-encoding检测"><a href="#mb-detect-encoding检测" class="headerlink" title="mb_detect_encoding检测"></a>mb_detect_encoding检测</h3><p><code>mb_detect_encoding</code>函数中<code>$encoding_list</code>参数中编码顺序不同，会影响最终检测的结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法：</span></span><br><span class="line">$coding = mb_detect_encoding($unameGbk, <span class="keyword">array</span>(<span class="string">'UTF-8'</span>, <span class="string">'GBK'</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$coding = mb_detect_encoding($unameGbk, <span class="keyword">array</span>(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line">var_dump(mb_detect_encoding(<span class="string">'hello'</span>, [<span class="string">'utf8'</span>, <span class="string">'gbk'</span>])); <span class="comment">// utf8</span></span><br><span class="line">var_dump(mb_detect_encoding(<span class="string">'hello'</span>, [<span class="string">'gbk'</span>, <span class="string">'utf8'</span>])); <span class="comment">// CP936 == gbk</span></span><br></pre></td></tr></table></figure><h3 id="自定义实现的is-utf8-和is-gbk-方法"><a href="#自定义实现的is-utf8-和is-gbk-方法" class="headerlink" title="自定义实现的is_utf8()和is_gbk()方法"></a>自定义实现的is_utf8()和is_gbk()方法</h3><p>这个来源是流传较广的一种写法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_utf8</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == preg_match(<span class="string">'%^(?:[\x09\x0A\x0D\x20-\x7E]'</span> .    <span class="comment">// ASCII</span></span><br><span class="line">            <span class="string">'| [\xC2-\xDF][\x80-\xBF]'</span> .                <span class="comment">//non-overlong 2-byte</span></span><br><span class="line">            <span class="string">'| \xE0[\xA0-\xBF][\x80-\xBF]'</span> .            <span class="comment">//excluding overlongs</span></span><br><span class="line">            <span class="string">'| [\xE1-\xEC\xEE\xEF][\x80-\xBF]&#123;2&#125;'</span> .    <span class="comment">//straight 3-byte</span></span><br><span class="line">            <span class="string">'| \xED[\x80-\x9F][\x80-\xBF]'</span> .            <span class="comment">//excluding surrogates</span></span><br><span class="line">            <span class="string">'| \xF0[\x90-\xBF][\x80-\xBF]&#123;2&#125;'</span> .        <span class="comment">//planes 1-3</span></span><br><span class="line">            <span class="string">'| [\xF1-\xF3][\x80-\xBF]&#123;3&#125;'</span> .            <span class="comment">//planes 4-15</span></span><br><span class="line">            <span class="string">'| \xF4[\x80-\x8F][\x80-\xBF]&#123;2&#125;'</span> .        <span class="comment">//plane 16</span></span><br><span class="line">            <span class="string">')*$%xs'</span>, $str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_gbk</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return preg_match('%^(?:[\x81-\xFE]([\x40-\x7E]|[\x80-\xFE]))*$%xs', $str);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == preg_match(<span class="string">'%^(?:[\x81-\xFE][\x40-\x7E]'</span> .</span><br><span class="line">            <span class="string">'| [\x81-\xFE][\x80-\xFE]'</span> .</span><br><span class="line">            <span class="string">'| [\x00-\x80])*$%xs'</span>, $str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iconv同编码转换后判等方式"><a href="#iconv同编码转换后判等方式" class="headerlink" title="iconv同编码转换后判等方式"></a>iconv同编码转换后判等方式</h3><ul><li>通过<code>iconv</code>判断转换前后的内容是否一致，作为编码检测的依据</li><li>优劣<ul><li>必须指定检测范围</li><li>在明确范围的情况下，检测准确性最佳</li></ul></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectEncoding</span> <span class="params">($str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>) <span class="keyword">as</span> $v) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($str === @iconv($v, $v . <span class="string">'//IGNORE'</span>, $str)) &#123;</span><br><span class="line">            <span class="keyword">return</span> $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h2><p>先看个正常的例子：</p><ul><li>小知识：GBK 和 CP936可以认为是同一种编码的不同叫法，CP936是GBK的实时实现。 </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">'天下相思'</span>;</span><br><span class="line">$strNew = mb_convert_encoding($str, <span class="string">'gbk'</span>, <span class="string">'utf8'</span>); <span class="comment">// 从utf8转码至gbk，讲道理strNew只能是gbk吧</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$coding = mb_detect_encoding($strNew, <span class="keyword">array</span>(<span class="string">'UTF-8'</span>, <span class="string">'GBK'</span>), <span class="keyword">true</span>); <span class="comment">// CP936</span></span><br><span class="line">$coding = mb_detect_encoding($strNew, <span class="keyword">array</span>(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>), <span class="keyword">true</span>); <span class="comment">// CP936</span></span><br><span class="line"><span class="comment">// 无论哪种方式检测，结果都是CP936，这就比较统一</span></span><br></pre></td></tr></table></figure><ul><li>再一个极端的例子，不论哪种方式检测，都无法做到100%正确？</li><li>此时严重依赖detectList中指定的待检测编码的顺序，也就是说可能误判为utf8，而此时如果输出则会乱码（实际并非utf8编码）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">'鸶姬'</span>; <span class="comment">// 本地utf8编码</span></span><br><span class="line">$strNew = mb_convert_encoding($str, <span class="string">'gbk'</span>, <span class="string">'utf8'</span>); <span class="comment">// 从utf8转码至gbk，讲道理strNew只能是gbk吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请问此时$strNew的编码是什么？编码检测工具检测出的结果如何？</span></span><br><span class="line"></span><br><span class="line">$coding = mb_detect_encoding($strNew, <span class="keyword">array</span>(<span class="string">'UTF-8'</span>, <span class="string">'GBK'</span>), <span class="keyword">true</span>); <span class="comment">// UTF-8</span></span><br><span class="line">$coding = mb_detect_encoding($strNew, <span class="keyword">array</span>(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>), <span class="keyword">true</span>); <span class="comment">// CP936</span></span><br><span class="line"></span><br><span class="line">var_dump(is_utf8($strNew)); <span class="comment">// true</span></span><br><span class="line">var_dump(is_gbk($strNew)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="结论-amp-注意事项"><a href="#结论-amp-注意事项" class="headerlink" title="结论&amp;注意事项"></a>结论&amp;注意事项</h3><ul><li>编码检测的准确性，验证依赖<code>detectList</code>待检测编码的顺序，应将范围小的在前，减少误判的概率（但无法避免）</li><li>同时存在不同编码下字符，编码值保持相同，所以编码检测结果是首个包含此字符的编码，如英文词汇的gbk/utf8编码结果相同</li><li>一种编码检测及转换为utf8的可行方案</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这里仅支持gbk/utf8的编码检测，且数据源多数为gbk编码</span></span><br><span class="line"><span class="comment">// 函数副作用：可能存在字符串检测结果既是gbk又是utf8，此方法会优先返回gbk</span></span><br><span class="line"><span class="comment">// 根据有限的几条测试情况，这种情况下，gbk-&gt;utf8的转码并不会改变字节码，结果一致</span></span><br><span class="line"><span class="comment">// 所以还是有局限性的，请明确使用范围和影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectEncoding</span> <span class="params">($str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>) <span class="keyword">as</span> $v) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($str === @iconv($v, $v . <span class="string">'//IGNORE'</span>, $str)) &#123;</span><br><span class="line">            <span class="keyword">return</span> $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入字符串，编码待确定，下面统一转换为utf8编码</span></span><br><span class="line">$str = <span class="string">'xxxx'</span>;</span><br><span class="line"><span class="keyword">if</span>(detectEncoding($str) == <span class="string">'GBK'</span>) &#123; <span class="comment">//  源字符串为gbk编码</span></span><br><span class="line">    $strUtf8 = mb_convert_encoding($str, <span class="string">'utf8'</span>, <span class="string">'gbk'</span>); <span class="comment">// 从gbk转码为utf8</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 源字符串为utf8编码</span></span><br><span class="line">    $strUtf8 = $str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终utf8编码的字符串保存在变量$strUtf8中</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码问题在Python同学眼中应该是老生常谈的，本文谈下PHP中常见的编码相关检测方法及局限&lt;/li&gt;
&lt;li&gt;数据在写入时决定了编码形式，而由于历史变更可能存在历史数据中写入编码不同&lt;/li&gt;
&lt;li&gt;编码检测的目的：检测数据的编码形式，正确解码及界面展示&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="http://fivezh.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>阿里云多种消息服务的差异及选型</title>
    <link href="http://fivezh.github.io/2019/04/24/ali-message-service/"/>
    <id>http://fivezh.github.io/2019/04/24/ali-message-service/</id>
    <published>2019-04-24T09:14:17.000Z</published>
    <updated>2019-09-18T06:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>背景</strong>：消息中间件日益在应用系统中必不可少，阿里云提供多种消息MessageQueue服务，有历史原因也有产品线不统一或尽可能提供用户更多选择的原因。笔者根据实际使用，总结下阿里云消息服务的历史、不同消息服务的差异、最后给出推荐选用原则。<br><a id="more"></a></p><h2 id="阿里云消息服务现状"><a href="#阿里云消息服务现状" class="headerlink" title="阿里云消息服务现状"></a>阿里云消息服务现状</h2><p>目前阿里云提供多种消息队列服务：</p><ul><li><a href="https://cn.aliyun.com/product/mns" target="_blank" rel="noopener">阿里云消息服务MNS</a></li><li><a href="https://www.aliyun.com/product/rocketmq" target="_blank" rel="noopener">消息队列RocketMQ</a></li><li><a href="https://www.aliyun.com/product/amqp" target="_blank" rel="noopener">消息队列AMQP(RabbitMQ)</a></li><li><a href="https://www.aliyun.com/product/mq4iot" target="_blank" rel="noopener">微消息队列MQTT for IoT</a></li><li><a href="https://www.aliyun.com/product/kafka" target="_blank" rel="noopener">消息队列 Kafka</a></li></ul><p>这里我们只关注笔者目前使用的两个<code>消息队列Message Queue</code>中间件：</p><ul><li>消息服务MNS</li><li>消息队列RocketMQ</li></ul><h2 id="阿里云消息服务MNS和RocketMQ的历史"><a href="#阿里云消息服务MNS和RocketMQ的历史" class="headerlink" title="阿里云消息服务MNS和RocketMQ的历史"></a>阿里云消息服务MNS和RocketMQ的历史</h2><h3 id="消息服务MNS"><a href="#消息服务MNS" class="headerlink" title="消息服务MNS"></a>消息服务MNS</h3><p>原名MQS，阿里在2012年立项自研项目，2014年阿里云上线公测，2015年改名MNS服务，最后更新时间为2015年12月。</p><p>从历史可以看到MNS消息队列从最早12年立项自研，历经MQS改名为MNS，15年后稳定提供云服务。</p><p>笔者从16年接触使用MNS，到目前仍有100+队列线上运行，从实际使用情况看，总结如下：</p><ul><li>稳定性：三年未发生过大的事故，除了某次阿里云机房故障，各云服务均受影响</li><li>可靠性：线上未发生消息丢失，多方对账验证也未发现</li><li>顺序性：<strong>不保证消息有序</strong>，虽然提供<code>Python</code>版的内存排序方案，但无法保证严格有序</li><li>价格：非常便宜，2元/百万次，几乎相当于不要钱了</li><li>不足：监控、报警由于不开放API，只能依赖阿里云的云监控，收费项目</li></ul><h3 id="消息队列RocketMQ"><a href="#消息队列RocketMQ" class="headerlink" title="消息队列RocketMQ"></a>消息队列RocketMQ</h3><p>阿里借鉴Kafka设计思想，并优化低延迟、高可靠性方案，研发出来内部高性能、高可靠、功能完备的RocketMQ，同时提供开源和云服务。</p><blockquote><p>消息队列 RocketMQ 是阿里巴巴集团自主研发的专业消息中间件，基于高可用分布式集群技术，提供消息订阅和发布、消息轨迹查询以及定时（延时）消息、资源统计、监控报警等一系列消息云服务，是企业级互联网架构的核心产品。 消息队列 RocketMQ 历史超过9年，为分布式应用系统提供异步解耦、削峰填谷的能力，同时具备海量消息堆积、高吞吐、可靠重试等互联网应用所需的特性，是阿里巴巴双11使用的核心产品。</p></blockquote><p>主要特性：</p><ul><li>消息类型：普通消息、定时/延时消息、顺序消息、事务消息</li><li>消息<code>Exactly-Once 投递</code>，此<a href="https://help.aliyun.com/document_detail/102777.html" target="_blank" rel="noopener">特性</a>仅支持Java SDK</li><li>顺序消息：云服务RocketMQ支持<strong>全局有序</strong>和分区有序<ul><li>全局有序这个太厉害了，目前开源实现版本貌似不支持</li></ul></li><li>支持消息回溯</li><li>支持消息轨迹（消息状态跟踪）</li></ul><p>注意事项：</p><ul><li>消息重复无法避免，业务上应根据唯一Key来做幂等性处理<ul><li>发送时消息重复：发送过程网络或Client异常，重试则消息重复</li><li>投递时消息重复：接收过程网络或Client异常，为保证<code>At Least Once</code>，重试则消息重复</li><li>负载均衡时消息重复：Broker重启、扩容、缩容，触发消息Rebalance，可能消息重复</li></ul></li><li>MessageId不保证全局唯一，业务上应设置MessageKey来保证唯一性</li><li>TCP版SDK仅支持Java、C/C++、.NET，不支持PHP/Go/Python等语言</li><li>HTTP版SDK支持Go/Python/Nodejs/PHP/Java/C++/C#</li><li><strong>RocketMQ未支持优先级队列</strong></li></ul><h3 id="消息队列-AMQP（RabbitMQ）"><a href="#消息队列-AMQP（RabbitMQ）" class="headerlink" title="消息队列 AMQP（RabbitMQ）"></a>消息队列 AMQP（RabbitMQ）</h3><blockquote><p>消息队列 AMQP 由阿里云基于 AMQP 标准协议研发，完全兼容 RabbitMQ 开源生态以及多语言客户端，打造分布式、高吞吐、低延迟、高可扩展的云消息服务。开箱即用，用户无需部署免运维，轻松实现快速上云，阿里云提供全托管服务，更专业、更可靠、更安全。</p></blockquote><p>特性及注意事项：</p><ul><li>定时消息：开源版RabbitMQ不支持</li><li>死信队列</li><li>完全兼容 AMQP 标准协议和 RabbitMQ 开源生态</li><li>目前阿里云版仅提供Java版SDK</li></ul><h2 id="云服务：MNS和ONS中消息队列RocketMQ的对比"><a href="#云服务：MNS和ONS中消息队列RocketMQ的对比" class="headerlink" title="云服务：MNS和ONS中消息队列RocketMQ的对比"></a>云服务：MNS和ONS中消息队列RocketMQ的对比</h2><p><img src="/assets/post_images/MNS_ONS.png" alt=""><br>引用阿里中间件团队的<a href="http://jm.taobao.org/2016/04/01/kafka-vs-rabbitmq-vs-rocketmq-message-send-performance/" target="_blank" rel="noopener">RocketMQ、RabbitMQ、Kafka同步发送性能对比</a>：Kafka &gt; RocketMQ &gt; RabbitMQ</p><h2 id="推荐选用原则"><a href="#推荐选用原则" class="headerlink" title="推荐选用原则"></a>推荐选用原则</h2><p>分析业务实际需求、潜在需求，对消息系统的功能性要求有哪些，主要考虑的特性：</p><table><thead><tr><th>特性</th><th>RocketMQ</th><th>MNS</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>有序性</td><td>全局有序+分区有序</td><td><strong>Client内存排序</strong></td><td>单Producer+同Exchange/Queue+单消费Channel可保证有序</td></tr><tr><td>可靠性</td><td>高</td><td>高</td><td>高</td></tr><tr><td>拉取模式</td><td>Pull/Push</td><td>Pull/Push</td><td>Pull/Push</td></tr><tr><td>发送性能</td><td>1万</td><td>3000</td><td>1万</td></tr><tr><td>优先级队列</td><td><strong>不支持</strong></td><td>支持</td><td>支持</td></tr><tr><td>延时队列</td><td>支持</td><td>支持</td><td><strong>非原生支持</strong></td></tr><tr><td>价格</td><td>普通：2元/百万次API请求；事务/顺序/定时消息：5倍计费</td><td>2元/百万次API请求</td><td>同RocketMQ</td></tr></tbody></table><blockquote><p>RabbitMQ非原生支持延时队列，仅支持消息或队列的TTL超时，但无法灵活实现延时策略，<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">rabbitmq-delayed-message-exchange</a>插件支持毫秒级延时队列方案，但对性能等影响应全面评估。</p></blockquote><p>如果在云服务选择的话，建议：</p><ul><li>要求顺序性：选择RocketMQ</li><li>要求优先级：可用RabbitMQ或MNS</li><li>要求发送速度：超过5000，选择RocketMQ；低于2000/s，均可</li><li>价格上二者相当，按调用次数或套餐包、Topic使用费计费</li><li>注意：使用云服务，则必须使用阿里云的云监控来做监控报警</li></ul><h2 id="我们团队目前的选择"><a href="#我们团队目前的选择" class="headerlink" title="我们团队目前的选择"></a>我们团队目前的选择</h2><ul><li>团队基于RabbitMQ搭建的消息队列集群服务<ul><li>由5台4C8G集群组成</li><li>开启持久化、队列镜像</li><li>性能满足10倍扩容的需求</li></ul></li><li>基于RabbitMQ API和Prometheus增加报警监控</li><li>增加多租户配置管理后台，减少接入配置成本</li><li>增加SDK降低使用方Client接入成本</li><li>增加消息跟踪，支持生产者、消费者两端的消息状态查询</li><li>增加消息重放，在消息跟踪的基础上实现</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://help.aliyun.com/document_detail/27417.html" target="_blank" rel="noopener">阿里云MNS发展历史</a></li><li><a href="http://blog.wentong.me/2016/01/message-queue-research/" target="_blank" rel="noopener">几款消息中间的调研</a></li><li><a href="http://jm.taobao.org/2016/04/01/kafka-vs-rabbitmq-vs-rocketmq-message-send-performance/" target="_blank" rel="noopener">Kafka、RabbitMQ、RocketMQ消息中间件的对比 —— 消息发送性能</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：消息中间件日益在应用系统中必不可少，阿里云提供多种消息MessageQueue服务，有历史原因也有产品线不统一或尽可能提供用户更多选择的原因。笔者根据实际使用，总结下阿里云消息服务的历史、不同消息服务的差异、最后给出推荐选用原则。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>[译]sync.RWMutex - 解决并发读写问题</title>
    <link href="http://fivezh.github.io/2019/04/09/sync_mutex_translation/"/>
    <id>http://fivezh.github.io/2019/04/09/sync_mutex_translation/</id>
    <published>2019-04-09T06:41:21.000Z</published>
    <updated>2019-09-18T06:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文地址：<a href="https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0" target="_blank" rel="noopener">https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0</a></li><li>原文作者：<a href="https://medium.com/@mlowicki" target="_blank" rel="noopener">Michał Łowicki</a></li><li>译文出处：<a href="https://medium.com" target="_blank" rel="noopener">https://medium.com</a></li><li>本文永久链接：<a href="https://github.com/gocn/translator/blob/master/2019/w13_sync_mutex_translation.md" target="_blank" rel="noopener">https://github.com/gocn/translator/blob/master/2019/w13_sync_mutex_translation.md</a></li><li>译者：<a href="https://github.com/fivezh" target="_blank" rel="noopener">fivezh</a></li><li>校对者：<a href="https://github.com/watermelo" target="_blank" rel="noopener">咔叽咔叽</a></li></ul><a id="more"></a><p><img src="https://cdn-images-1.medium.com/max/1000/1*qmHZVxZmPP9w5iMqN7GWMw.jpeg" alt=""></p><p>当多个线程访问共享数据时，会出现并发读写问题（<a href="https://en.wikipedia.org/wiki/readers%E2%80%93writers_problem" target="_blank" rel="noopener">reader-writer problems</a>）。有两种访问数据的线程类型：</p><ul><li>读线程 reader：只进行数据读取</li><li>写线程 writer：进行数据修改</li></ul><p>当 writer 获取到数据的访问权限后，其他任何线程（reader 或 writer）都无权限访问此数据。这种约束亦存在于现实中，比如，当 writer 在修改数据无法保证原子性时（如数据库），此时读取未完成的修改必须被阻塞，以防止加载脏数据（译者注：数据库中的脏读）。还有许多诸如此类的核心问题，例如：</p><ul><li>writer 不能无限等待</li><li>reader 不能无限等待</li><li>不允许线程出现无限等待</li></ul><p>多读/单写互斥锁（如<a href="https://golang.org/pkg/sync/#RWMutex" target="_blank" rel="noopener">sync.RWMutex</a>）的具体实现解决了一种并发读写问题。接下来，让我们看下在 Go 语言中是如何实现的，同时它提供了哪些的数据可靠性保证机制。</p><p>作为额外的工作，我们将深入研究分析竞态情况下的互斥锁。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在深入研究实现细节之前，我们先看看<code>sync.RWMutex</code>的使用实例。下面的程序使用读写互斥锁来保护临界区–<code>sleep()</code>。为了更好的展示整个过程，临界区部分计算了当前正在执行的 reader 和 writer 的数量（<a href="https://play.golang.org/p/xoiqW0RQQE9" target="_blank" rel="noopener">源码</a>）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reader</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>, m *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    sleep()</span><br><span class="line">    m.RLock()</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    sleep()</span><br><span class="line">    c &lt;- <span class="number">-1</span></span><br><span class="line">    m.RUnlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>, m *sync.RWMutex, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    sleep()</span><br><span class="line">    m.Lock()</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    sleep()</span><br><span class="line">    c &lt;- <span class="number">-1</span></span><br><span class="line">    m.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">    <span class="keyword">var</span> rs, ws <span class="keyword">int</span></span><br><span class="line">    rsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n := &lt;-rsCh:</span><br><span class="line">                rs += n</span><br><span class="line">            <span class="keyword">case</span> n := &lt;-wsCh:</span><br><span class="line">                ws += n</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%s%s\n"</span>, strings.Repeat(<span class="string">"R"</span>, rs),</span><br><span class="line">                    strings.Repeat(<span class="string">"W"</span>, ws))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> reader(rsCh, &amp;m, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> writer(wsCh, &amp;m, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>play.golang.org 加载的程序环境是确定的（比如开始时间），所以<code>rand.Seed(time.Now().Unix())</code>总是返回相同的数值，此时程序的执行结果可能总是相同的。为了避免这种情况，可通过修改不同的随机种子值或者在自己的机器上执行程序。</p></blockquote><p>程序执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">W</span><br><span class="line"></span><br><span class="line">R</span><br><span class="line">RR</span><br><span class="line">RRR</span><br><span class="line">RRRR</span><br><span class="line">RRRRR</span><br><span class="line">RRRR</span><br><span class="line">RRR</span><br><span class="line">RRRR</span><br><span class="line">RRR</span><br><span class="line">RR</span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">W</span><br><span class="line"></span><br><span class="line">R</span><br><span class="line">RR</span><br><span class="line">RRR</span><br><span class="line">RRRR</span><br><span class="line">RRR</span><br><span class="line">RR</span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">W</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：不同机器上运行的结果会有所不同<br>每次执行完一组 goroutine（reader 和 writer）的临界区代码后，都会打印新的一行。很显然，RWMutex 允许至少一个 reader（一个或多个 reader）存在而 writer 同时只能存在一个。</p></blockquote><p>同样重要且将进一步讨论的是：writer 调用到<code>Lock()</code>时，将会使新的 reader/writer 被阻塞。当存在 reader 加了 RLock 时，writer 会等待这一组 reader 完成正在执行的任务，当这一组任务完成后，writer 将开始执行。从输出可以很明显的看到，每一行的 R 都会递减一个，直到没有 R 之后将打印一个 W。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">RRRRR</span><br><span class="line">RRRR</span><br><span class="line">RRR</span><br><span class="line">RR</span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">W</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>一旦 writer 结束，之前被阻塞的 reader 将恢复执行，然后下一个 writer 也将开始启动。值得一提的是，如果一个 writer 完成，并且有 reader 和 writer 都在等待，那么首个 reader 将解除阻塞，然后才轮到 writer。这种交替执行的方式使得 writer 需等待当前这组 reader 完成，所以无论 reader 还是 writer 都不会有无限等待的情况。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*Gg_vmyWlU35r3w_L4r4SYw.jpeg" alt=""></p><blockquote><p>注意，本文针对的<code>RWMutex</code>实现(<a href="https://github.com/golang/go/blob/718d6c5880fe3507b1d224789b29bc2410fc9da5/src/sync/rwmutex.go" target="_blank" rel="noopener">Go commit: 718d6c58</a>)在 Go 不同版本中可能随时有修改。<br><code>RWMutex</code>为 reader 提供两个方法（<code>RLock</code>和<code>RUnlock</code>）、也为 writer 提供了两个方法（<code>Lock</code>和<code>Unlock</code>）</p></blockquote><h2 id="读锁-RLock"><a href="#读锁-RLock" class="headerlink" title="读锁 RLock"></a>读锁 RLock</h2><p>为了简洁起见，我们先跳过源码中竞态检测相关部分（它们将被<code>...</code>代替）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;    </span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.ReadeSem, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>readerCount</code>字段是<code>int32</code>类型的值，表示待处理的 reader 数量（正在读取数据或被 writer 阻塞）。这基本上是已调用 RLock 函数，但尚未调用 RUnlock 函数的 reader 数量。</p><p><a href="https://golang.org/pkg/sync/atomic/#AddInt32" target="_blank" rel="noopener">atomic.AddInt32</a>等价于如下原子性表达：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*addr += delta</span><br><span class="line"><span class="keyword">return</span> *addr</span><br></pre></td></tr></table></figure></p><p><code>addr</code>是<code>*int32</code>类型变量，<code>delta</code>是<code>int32</code>类型。因为此操作具有原子性，所以累加<code>delta</code>操作不会影响其他线程（更多详见<a href="https://en.wikipedia.org/wiki/Fetch-and-add" target="_blank" rel="noopener">Fetch-and-add</a>）。</p><blockquote><p>如果没有 writer，则<code>readerCount</code>总是会大于或等于 0（译者注：因为 writer 会把 readerCount 置为负数，通过 Lock 函数的 atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxreaders)，此时 reader 是一种运行速度很快的非阻塞方式，因为只需要调用<code>atomic.AddInt32</code>。</p></blockquote><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>信号量是 Edsger Dijkstra 发明的数据结构，在解决多种同步问题时很有用。其本质是一个整数，并关联两个操作：</p><ul><li>申请<code>acquire</code>（也称为 <code>wait</code>、<code>decrement</code> 或 <code>P</code> 操作）</li><li>释放<code>release</code>（也称 <code>signal</code>、<code>increment</code> 或 <code>V</code> 操作）</li></ul><p><code>acquire</code>操作将信号量减 1，如果结果值为负则线程阻塞，且直到其他线程进行了信号量累加为正数才能恢复。如结果为正数，线程则继续执行。</p><p><code>release</code>操作将信号量加 1，如存在被阻塞的线程，此时他们中的一个线程将解除阻塞。</p><p>Go 运行时提供的<code>runtime_SemacquireMutex</code>和<code>runtime_Semrelease</code>函数可用来实现<code>sync.RWMutex</code>互斥锁。</p><h2 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁 Lock"></a>锁 Lock</h2><p>实现源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxreader) + rwmutexMaxreader</span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;     </span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>writer 通过<code>Lock</code>方法获取共享数据的独占权限。首先，它会申请阻塞其他写操作的互斥锁（<code>rw.w.Lock()</code>），此互斥锁在<code>Unlock</code>函数的最后才会进行解锁。下一步，将<code>readerCount</code>减去<code>rwmutexMaxreader</code>（值为 1 左移 30 位, <code>1&lt;&lt;30</code>）使其为负数。当<code>readerCount</code>变为负数时，Rlock 将阻塞接下来的所有读请求。</p><p>再回过头来看下<code>Rlock()</code>函数中逻辑：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// A writer is pending, wait for it.    </span></span><br><span class="line">    runtime_SemacquireMutex(&amp;rw.SeadeSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续的 reader 将会被阻塞，那么已运行的 reader 会怎样呢？<code>readerWait</code>字段用来记录当前 reader 执行的数量。writer 被信号量<code>writerSem</code>阻塞，直到最后一个 reader 在使用后面讨论的<code>RUnlock</code>方法解锁后会把<code>writerSem</code>加 1，此时信号量将变成 0，<code>writer</code>被解除阻塞（译者注：RUnlock 函数中的<code>runtime_Semrelease(&amp;rw.writerSem, false)</code>）</p><p>如果没有有效的 reader，那么 writer 将继续其执行。</p><h2 id="最大-reader-数-rwmutexMaxreader"><a href="#最大-reader-数-rwmutexMaxreader" class="headerlink" title="最大 reader 数 rwmutexMaxreader"></a>最大 reader 数 rwmutexMaxreader</h2><p>在<a href="https://github.com/golang/go/blob/718d6c5880fe3507b1d224789b29bc2410fc9da5/src/sync/rwmutex.go" target="_blank" rel="noopener">rwmutex.go</a>中定义的常量：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxreader = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><p>那么，其用途是什么，以及<code>1&lt;&lt;30</code>表示什么意义呢？</p><p><code>readerCount</code>字段是<a href="https://golang.org/pkg/builtin/#int32" target="_blank" rel="noopener">int32</a>类型，其范围为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-1 &lt;&lt; 31, (1 &lt;&lt; 31) — 1] or [-2147483648, 2147483647]</span><br></pre></td></tr></table></figure></p><p><code>RWMutext</code>使用此字段来计算挂起的 reader 和 writer 的标记（置为负数）。在<code>Lock</code>方法中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxreader) + rwmutexMaxreader</span><br></pre></td></tr></table></figure><p><code>Lock</code>会将<code>readerCount</code>字段减去<code>1&lt;&lt;30</code>，当<code>readerCount</code>负值时表示 writer 调用了<code>Lock</code>正等待被处理，<code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxreaders) + rwmutexMaxreaders</code>这个操作既让<code>readerCount</code>变为负数又使<code>r</code>存储回了 readerCount。<code>rwmutexMaxreaders</code>也可以限制被挂起 reader 的数量。如果有<code>rwmutexMaxreader</code>个或更多挂起的 reader，那么<code>readerCount</code>将是非负值，此时将导致整个机制的崩溃。所以，reader 实际的限制数是：<code>rwmutexMaxreader - 1</code>，此值<code>1073741823</code>超过了<code>10亿</code>。</p><h2 id="解读锁-RUnlock"><a href="#解读锁-RUnlock" class="headerlink" title="解读锁 RUnlock"></a>解读锁 RUnlock</h2><p>实现源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxreader &#123;</span><br><span class="line">            race.Enable()</span><br><span class="line">            thrSw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A writer is pending.</span></span><br><span class="line">        <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// The last reader unblocks the writer.       </span></span><br><span class="line">            runtime_Semrelease(&amp;rw.WriteSem, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次调用此方法将使<code>readerCount</code>减 1（RLock 方法中增加 1）。如果减完后<code>readerCount</code>值为负，则表示当前存在 writer 正在等待或运行。这是因为在<code>Lock()</code>方法中<code>readerCount</code>减去了<code>rwmutexMaxreader</code>。然后，当检查到将完成的 reader 数量（readerWait 数值）最终为 0 时，则表示 writer 可以最终申请信号量。（译者注：<code>r &lt; 0</code>时，存在两个分支，当走 r+1 == 0 的分支时，表示 readerCount 此时为 0 即没有 RLock，所以 throw 了。当走下面那个分支时，<code>r &lt; 0</code>则是因为存在 writer 把 readerCount 置为了负数在等待 reader 结束，那么当最后一个 reader 解锁时需要将 WriteSem 信号量加 1，唤醒 writer）</p><h2 id="解锁-Unlock"><a href="#解锁-Unlock" class="headerlink" title="解锁 Unlock"></a>解锁 Unlock</h2><p>实现源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxreader)</span><br><span class="line">    <span class="keyword">if</span> r &gt;= rwmutexMaxreader &#123;</span><br><span class="line">        race.Enable()</span><br><span class="line">        throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解锁被 writer 持有的互斥锁时，首先通过<code>atomic.AddInt32</code>将<code>readerCount</code>加上<code>rwmutexMaxreader</code>，这时<code>readerCount</code>将变成非负值。如<code>readerCount</code>比 0 大，则表示存在 reader 正在等待 writer 执行完成，此时应唤醒这些等待的 reader。之后写锁将被释放，从而允许其他 writer 为了写入而锁定互斥锁。（译者注：如果还存在挂起的 reader，则在 writer 解锁之前需要通过信号量 readerSem 唤醒这些 reader 执行）</p><p>如果 reader 或 writer 尝试解锁未锁定的互斥锁时，调用<code>Unlock</code>或<code>Runlock</code>方法将抛出错误（<a href="https://play.golang.org/p/YMdFET74olU" target="_blank" rel="noopener">示例源码</a>）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := sync.RWMutex&#123;&#125;</span><br><span class="line">m.Unlock()</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal error: sync: Unlock of unlocked RWMutex</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="递归读锁定-Recursive-read-locking"><a href="#递归读锁定-Recursive-read-locking" class="headerlink" title="递归读锁定 Recursive read locking"></a>递归读锁定 Recursive read locking</h2><p>文档描述：</p><blockquote><p>如果一个 reader goroutine 持有了读锁，而此时另一个 writer goroutine 调用<code>Lock</code>申请加写锁，此后在最初的读锁被释放前其他 goroutine 不能获取到读锁。特定情况下，这能防止递归读锁，这种策略保证了锁的可用性，<code>Lock</code>的调用会阻止其他新的 reader 来获得锁。</p></blockquote><p>RWMutex 的工作方式是，如果有一个 writer 调用了 Lock，则所有调用 RLock 都将被锁定，无论是否已经获得了读锁定（<a href="https://play.golang.org/p/oHvZh4u3nJl" target="_blank" rel="noopener">示例源码</a>）:<br>示例代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"RLock"</span>)</span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"RUnlock"</span>)</span><br><span class="line">        m.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(<span class="string">"Lock"</span>)</span><br><span class="line">        m.Lock()</span><br><span class="line">        fmt.Println(<span class="string">"Unlock"</span>)</span><br><span class="line">        m.Unlock()</span><br><span class="line">        done &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    f(<span class="number">4</span>)</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RLock</span><br><span class="line">RLock</span><br><span class="line">RLock</span><br><span class="line">Lock</span><br><span class="line">RLock</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure></p><p>译者注（至下一节以前均为译者注）：为什么会发送死锁呢？原作者用递归函数在 defer 里面解锁，那么在加第三层读锁的时候，还没有读锁解锁。这时，readCount 是 3，此时正好加了一个 Lock 写锁，由于 readCount 是 3</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">         runtime_Semacquire(&amp;rw.writerSem)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>由上可知，此时 writer 需要等待所有进行中的 reader 完成，此时又调用了 RLock，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_Semacquire(&amp;rw.readerSem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在第四个 RLock 前，加了 Lock 操作，使得 readerCount 为负数。所以就造成了死锁，即 reader 在等待 readerSem，writer 在等待 writerSem*</p><h2 id="复制锁-Copying-locks"><a href="#复制锁-Copying-locks" class="headerlink" title="复制锁 Copying locks"></a>复制锁 Copying locks</h2><p><code>go tool vet</code>可以检测锁是否被复制了，因为复制锁会导致死锁。更多关于此问题可参考之前的文章：<a href="https://medium.com/golangspec/detect-locks-passed-by-value-in-go-efb4ac9a3f2b" target="_blank" rel="noopener">Detect locks passed by value in Go</a></p><h2 id="性能-Performance"><a href="#性能-Performance" class="headerlink" title="性能 Performance"></a>性能 Performance</h2><p>之前有人发现，在 CPU 核数增多时 RWMutex 的性能会有下降，详见：<a href="https://github.com/golang/go/issues/17973" target="_blank" rel="noopener">sync: RWMutex scales poorly with CPU count</a></p><h2 id="争用-Contention"><a href="#争用-Contention" class="headerlink" title="争用 Contention"></a>争用 Contention</h2><p>Go 版本 ≥ 1.8 之后，支持分析争用的互斥锁（<a href="https://github.com/golang/go/commit/ca922b6d363b6ca47822188dcbc5b92d912c7a4b" target="_blank" rel="noopener">runtime: Profile goroutines holding contended mutexes.</a>）。我们来看下如何做：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    _ <span class="string">"net/http/pprof"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    runtime.SetMutexProfileFraction(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt; <span class="keyword">go</span> build mutexcontention.<span class="keyword">go</span></span><br><span class="line">&gt; ./mutexcontention</span><br></pre></td></tr></table></figure></p><p>当<code>mutexcontention</code>程序运行时，执行 pprof：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; go tool pprof mutexcontention http://localhost:8888/debug/pprof/mutex?debug=1</span><br><span class="line">Fetching profile over HTTP from http://localhost:8888/debug/pprof/mutex?debug=1</span><br><span class="line">Saved profile in /Users/mlowicki/pprof/pprof.mutexcontention.contentions.delay.003.pb.gz</span><br><span class="line">File: mutexcontention</span><br><span class="line">Type: delay</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) list main</span><br><span class="line">Total: 57.28s</span><br><span class="line">ROUTINE main.main.func1 in .../src/github.com/mlowicki/mutexcontention/mutexcontention.go</span><br><span class="line">0     57.28s (flat, cum)   100% of Total</span><br><span class="line">.          .     14:   for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">.          .     15:           go func() &#123;</span><br><span class="line">.          .     16:                   for &#123;</span><br><span class="line">.          .     17:                           mu.Lock()</span><br><span class="line">.          .     18:                           time.Sleep(100 * time.Millisecond)</span><br><span class="line">.     57.28s     19:                           mu.Unlock()</span><br><span class="line">.          .     20:                   &#125;</span><br><span class="line">.          .     21:           &#125;()</span><br><span class="line">.          .     22:   &#125;</span><br><span class="line">.          .     23:</span><br><span class="line">.          .     24:   http.ListenAndServe(&quot;:8888&quot;, nil)</span><br></pre></td></tr></table></figure></p><p>注意，为什么这里耗时 57.28s，且指向了<code>mu.Unlock()</code>呢？</p><p>当 goroutine 调用<code>Lock</code>而阻塞时，会记录当前发生的准确时间–叫做<code>acquiretime</code>。当另一个 groutine 解锁，至少存在一个 goroutine 在等待获得锁，则其中一个解除阻塞并调用其<code>mutexevent</code>函数。该<code>mutexevent</code>函数通过检查<code>SetMutexProfileFraction</code>设置的速率来决定此事件应被保留还是丢弃。此事件包含整个等待的时间（当前时间 - 获得时间）。从上面的例子可以看出，所有阻塞在特定互斥锁的 goroutines 的总等待时间会被收集和展示。</p><p>在 Go 1.11（<a href="https://github.com/golang/go/commit/88ba64582703cea0d66a098730215554537572de" target="_blank" rel="noopener">sync: enable profiling of RWMutex</a>）中将增加读锁（Rlock 和 RUnlock）的争用。</p><h3 id="资料-Resources"><a href="#资料-Resources" class="headerlink" title="资料 Resources"></a>资料 Resources</h3><ul><li>Allen B. Downey: The Little Book of Semaphores</li><li><a href="https://golang.org/pkg/sync/#RWMutex" target="_blank" rel="noopener">Documentation of sync.RWMutex</a></li><li><a href="https://en.wikipedia.org/wiki/reader%E2%80%93writer_problem" target="_blank" rel="noopener">Wikipedia: reader-writer problem</a></li><li><a href="https://medium.com/golangspec/reusable-barriers-in-golang-156db1f75d0b" target="_blank" rel="noopener">Reusable barriers in Golang</a></li><li><a href="https://medium.com/golangspec/synchronization-queues-in-golang-554f8e3a31a4" target="_blank" rel="noopener">Synchronization queues in Golang</a></li></ul><p>备注：</p><ul><li>critical section：临界区</li><li>Mutual exclusion，缩写 Mutex：互斥锁 </li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://medium.com/@mlowicki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Michał Łowicki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出处：&lt;a href=&quot;https://medium.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/gocn/translator/blob/master/2019/w13_sync_mutex_translation.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gocn/translator/blob/master/2019/w13_sync_mutex_translation.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/fivezh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fivezh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/watermelo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;咔叽咔叽&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="http://fivezh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>缓存系统中面临的雪崩/穿透/一致性问题</title>
    <link href="http://fivezh.github.io/2019/02/11/cache-things/"/>
    <id>http://fivezh.github.io/2019/02/11/cache-things/</id>
    <published>2019-02-11T06:03:28.000Z</published>
    <updated>2019-09-18T06:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>   There are only two hard things in Computer Science: cache invalidation and naming things.<br>   计算机科学中有两件难事：缓存失效和命名<br>   – Phil Karlton</p></blockquote><p>From <a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="noopener">Martin Fowler : TwoHardThings</a></p><p>缓存系统一定程度上极大提升系统并发能力，但同样也增加额外技术考虑因素，下面针对缓存系统设计与使用中面临的常见问题展开。</p><ul><li>缓存应用的典型场景</li><li>缓存雪崩</li><li>缓存穿透</li><li>缓存更新与数据一致性<a id="more"></a></li></ul><h2 id="缓存应用的典型场景"><a href="#缓存应用的典型场景" class="headerlink" title="缓存应用的典型场景"></a>缓存应用的典型场景</h2><p><img src="/assets/post_images/cache_system.png" alt="Cache通用部署"></p><p>请求-&gt;缓存-&gt;命中缓存则返回数据-&gt;无缓存则读取原始数据源</p><p><code>缓存定位</code>：前置数据加载，避免数据回源，提供高性能、高并发的数据读取能力；只有未命中缓存时才进行数据回源，极大减轻原始数据读取的压力</p><p><code>缓存分类</code>：按缓存系统所处位置不同，分为本地缓存、分布式缓存</p><ul><li>本地缓存：内存级缓存、文件级缓存，内存级缓存优势在于本地内存I/O、高性能(单次内存寻址100ns)，缺点在于空间有限，无法多端数据同步，此类方案有PHP的Opcache/Yac, Java中Encache/GuavaCache/SpringCache等；文件级缓存依赖磁盘I/O实现缓存作用，受机械磁盘寻道性能限制(单次磁盘读取时间10ms左右)，或考虑固态硬盘/Raid优化方案，较少使用</li><li>分布式缓存：Memcached、Redis等，分布式系统解决缓存容量问题，具备持续扩容能力，但不可避免一次网络I/O请求</li></ul><p>本文主要讨论<code>分布式缓存</code>系统设计与使用中面临的问题。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>定义：<strong>缓存雪崩是指缓存系统失效，导致大量请求同时进行数据回源，导致数据源压力骤增而崩溃</strong>。两种情况会导致此问题：1、多个缓存数据同时失效；2、缓存系统崩溃</p><h3 id="缓存同时失效"><a href="#缓存同时失效" class="headerlink" title="缓存同时失效"></a>缓存同时失效</h3><ul><li>在大量缓存同时失效的情况下，请求回源，导致数据源请求暴增而崩溃，系统全局不可用</li><li>缓存时间设置原则：根据<strong>缓存数据访问规律和缓存数据不一致的敏感性</strong>要求来选择缓存时间</li><li>缓存数据访问规律：如不同缓存数据访问无规律或相对离散，则不会存在这些缓存数据同时失效的情况；如<strong>缓存数据为批量写入</strong>(定时任务预热)，应考虑将<strong>缓存时间离散化</strong>，避免同时失效的情况下大量回源请求</li><li>缓存数据不一致的敏感性：不同应用场景下对缓存数据的一致性要求不同，缓存时间的设置视情况而定</li><li>这里也涉及到缓存更新策略问题，错误的更新策略可能会先删除缓存，再设置缓存，此时间差范围内的请求会进行回源，会导致此问题</li></ul><p>如何避免应考虑：<code>缓存失效时间离散化</code></p><h3 id="缓存系统故障"><a href="#缓存系统故障" class="headerlink" title="缓存系统故障"></a>缓存系统故障</h3><p>缓存系统整体故障，则整个缓存系统不可用，大量回源请求，且由于缓存系统故障无法回写缓存，导致无法快速恢复。</p><p>一句老话：为解决一个问题，引入新的解决方案，同时也必然引入新的问题。</p><p>这也是缓存系统的引入，在解决高性能、高并发的同时，引入了新的故障点。</p><p>考虑此问题，应从事前、事故中、事后不同阶段考虑：</p><ul><li>事前：增加缓存系统<strong>高可用方案设计</strong>，避免出现系统性故障</li><li>事故中：<ul><li>增加多级缓存，在单一缓存故障时，仍有其他缓存系统可用，如之前项目中使用的三级缓存方案：内存级缓存-&gt;Memcached-&gt;Redis这样的方案；</li><li>启用<code>熔断限流机制</code>，只允许可承受流量，避免全部流量压垮系统</li></ul></li><li>事后：缓存<strong>数据持久化</strong>，在故障后<strong>快速恢复</strong>缓存系统</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>定义：<strong>缓存穿透是指访问不存在数据，从而绕过缓存，直取数据源（大量数据源读取操作）</strong><br>解决缓存穿透的思路：</p><ul><li>不存在资源访问时，在缓存系统设置空值来拦截<ul><li>优点：实现简单</li><li>问题：大量非法请求时，缓存系统被填充大量非法值<br><img src="/assets/post_images/CacheNullValue.png" alt="缓存空值应对穿透问题"></li></ul></li><li>根据资源设置拦截机制（布隆过滤器bloomfilter或压缩filter过滤有效资源，如有效用户id等；也可以全局保存有效资源摘要，专用过滤、防穿透）<ul><li>优点：缓存系统空间利用较好</li><li>问题：过滤器实现机制和数据一致性要求<br><img src="/assets/post_images/CacheBloomFilter.png" alt="布隆规律器应对穿透问题"></li></ul></li></ul><h2 id="缓存更新与数据一致性"><a href="#缓存更新与数据一致性" class="headerlink" title="缓存更新与数据一致性"></a>缓存更新与数据一致性</h2><p>缓存系统数据的更新策略是需要专门开题来说的，建议阅读<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">左耳朵耗子：缓存更新的套路</a>系统了解，这里只根据实际经验给出在不同一致性要求下的建议。</p><p>一种常见缓存更新策略（此方案有问题）：</p><ul><li>读操作：命中缓存则返回，无缓存则取回源数据，写缓存</li><li>写操作：先删除缓存，再更新数据源</li></ul><p>问题场景：读写并发的场景下先删缓存操作可能导致脏数据入缓存</p><ul><li>写操作：删除缓存</li><li>读操作：无缓存则取回源数据（旧数据），回写缓存（此时缓存中为旧数据）</li><li>写操作：更新数据源</li><li>此时缓存数据不一致：缓存中为旧数据，数据源为新数据，出现缓存旧数据问题</li></ul><p>几种更新缓存的策略：</p><ul><li>Cache Aside Pattern：缓存失效时回源取数据，更新缓存；命中缓存时，返回缓存数据；先数据源更新后，再失效缓存（由等待下次读取来回写缓存）<ul><li>优势：无缓存旧数据问题、缓存系统维护简单、Facebook推荐方案</li><li>问题：无法绝对杜绝并发读写问题<ul><li>缓存过期的背景下，读操作回源取数据（此时为旧数据）</li><li>写操作：更新数据源，失效缓存</li><li>读操作：将回源数据（旧数据）写缓存，出现缓存数据不一致问题</li><li>这种问题出现概率极低，几点要求：缓存已过期、并发读写、读数据比写数据快、但读操作更新缓存比写操作失效缓存慢（也就是说写操作的行为需完全发生在读操作两步之间），一般而言读操作（读库+更新缓存）时长要小于写操作（更新数据源+失效缓存），所以认为这种并发问题概率较低</li><li>是否可进一步解决此问题：增加锁机制，解决并发问题</li></ul></li></ul></li><li>Read Through Pattern：更新数据源由缓存系统操作<ul><li><code>读取数据</code>时，如缓存失效，则缓存服务取回源数据更新缓存</li><li>而Cache Aside中是由应用服务（调用方）更新缓存</li><li>这套对调用方是透明的，只有一套存储系统，而无视缓存、数据源的差异</li></ul></li><li>Write Through Pattern：更新数据源由缓存系统操作<ul><li><code>写数据</code>时，如缓存失效，则直接更新数据源（不做任何缓存操作）；如命中缓存，则更新缓存（由缓存系统更新数据源）</li><li>在缓存失效下写操作的处理后，何时更新缓存呢？下一次读操作，按<code>Read Through</code>中缓存失效策略来更新缓存</li></ul></li><li>Write Behind Caching Pattern：又称<code>Write Back</code><ul><li>一句话总结：更新数据时，只更新缓存，不更新数据源（缓存<code>异步批量</code>更新数据源）</li><li>优势：<ul><li>更新缓存为内存操作，读写I/O非常高</li><li>异步批量更新数据源，合并多个操作</li></ul></li><li>问题：<ul><li><code>缓存不满足强一致性要求</code></li><li><code>强一致性和高性能的冲突</code>、<code>高可用和高性能的冲突</code>终究会使Trade-Off</li><li>实现复杂，需跟踪哪些Cache更新，成本较高</li></ul></li></ul></li></ul><p>总体来说，不同方案在不同场景下是有各自优劣的，技术选型、架构设计应根据实际场景取舍，并对选择方案的利弊有足够且深入理解。</p><p>一般而言，推荐<code>Cache Aside Pattern</code>方案，容忍较小概率的不一致（同时也可以增加锁机制解决此低概率并发问题），简化缓存系统复杂度。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank" rel="noopener">美团技术团队：缓存那些事</a></li><li><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">CoolShell：缓存更新的套路</a></li><li><a href="https://carlosfu.iteye.com/blog/2248185" target="_blank" rel="noopener">存系列文章–5.缓存穿透问题</a></li><li><a href="https://cachecloud.github.io/" target="_blank" rel="noopener">搜狐视频CacheCloud</a></li><li><a href="https://book.douban.com/subject/26971561/" target="_blank" rel="noopener">《Redis开发与运维》- 缓存设计章节</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;   There are only two hard things in Computer Science: cache invalidation and naming things.&lt;br&gt;   计算机科学中有两件难事：缓存失效和命名&lt;br&gt;   – Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;From &lt;a href=&quot;https://martinfowler.com/bliki/TwoHardThings.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Martin Fowler : TwoHardThings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;缓存系统一定程度上极大提升系统并发能力，但同样也增加额外技术考虑因素，下面针对缓存系统设计与使用中面临的常见问题展开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存应用的典型场景&lt;/li&gt;
&lt;li&gt;缓存雪崩&lt;/li&gt;
&lt;li&gt;缓存穿透&lt;/li&gt;
&lt;li&gt;缓存更新与数据一致性</summary>
    
    
    
    
    <category term="Redis" scheme="http://fivezh.github.io/tags/Redis/"/>
    
    <category term="Cache" scheme="http://fivezh.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>解析MySQL事务隔离级别</title>
    <link href="http://fivezh.github.io/2019/02/01/MySQL-Transaction-Isolation-Level/"/>
    <id>http://fivezh.github.io/2019/02/01/MySQL-Transaction-Isolation-Level/</id>
    <published>2019-02-01T03:22:26.000Z</published>
    <updated>2020-01-31T14:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>事务隔离是分布式系统对一致性保证的重要机制，是保证ACID的重要基础设施。<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">MySQL InnoDB事务隔离级别官方说明</a>中对MySQL的事务隔离机制有详细介绍。</p><p><img src="/assets/post_images/transaction_isolation_levels.png" alt="ANSI SQL STANDARD不同隔离级别对应问题"></p><p>结合示例，本文对<code>事务隔离级别</code>相关术语进行解析。<br><a id="more"></a></p><h2 id="MySQL四类事务隔离级别"><a href="#MySQL四类事务隔离级别" class="headerlink" title="MySQL四类事务隔离级别"></a>MySQL四类事务隔离级别</h2><p>事务隔离级别从高到低为：</p><ul><li><strong>READ UNCOMMITTED</strong>：未提交读<ul><li>读取未提交内容，所有事务可看到其他未提交事务的结果，很少实际使用</li><li>读取未提交的数据称为脏读（Dirty Read）</li></ul></li><li><strong>READ COMMITTED</strong>：提交读<ul><li>多数数据库的默认隔离级别（MySQL默认不是，默认为REPEATABLE-READ）</li><li>满足隔离的简单定义：<strong>一个事务只能看到已提交事务所做的改变</strong></li><li>这种隔离级别，支持所谓的不可重读（Non-repeatable Read），同一事务的其他实例在该实例过程中可能有新commit，所以同一个select可能返回不同结果（<strong>同一个事务如何做到其他实例？</strong>）</li></ul></li><li><strong>REPEATABLE READ</strong>：重复读<ul><li>可重复读(MySQL默认事务隔离)，但可能出现幻读(Phantom Read)</li><li><code>幻读(Phantom Read)</code>：当用户读取某范围数据行时，另一事务在此范围内<strong>插入新行</strong>，当用户再次读取此范围数据行时，读取到新的幻影行</li><li>InnoDB通过多版本并发控制MVCC机制解决该问题</li><li>PS：新版MySQL采用<code>Next-Key锁</code>来解决幻读问题</li></ul></li><li><strong>SERIALIZABLE</strong>：串行化<ul><li>最高隔离级别，强制事务排序（串行化），不会互相冲突</li><li>每个读数据航增加共享锁</li><li>此级别，可能导致大量超时现象和锁竞争</li></ul></li></ul><p>按事务隔离级别来说，级别越低数据一致性保障效果越差，而并发能力则越强。（一致性VS并发性是天然矛盾体）</p><h2 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h2><p>上述四种隔离级别采用不同的锁实现，对应级别下可能发生问题：</p><ul><li><strong>脏读（Dirty Read）</strong>：某事务已更新一份数据，而另一个事务此时读取了同一份数据，某些原因前一个更新做了回滚Rollback操作，则后一个事务数据是不正确的（读到了脏的数据）</li><li><strong>不可重复读（Non-repeatable read）</strong>：在<strong>一个事务的两次查询</strong>中数据不一致，可能是两次查询过程中另一个事务更新了数据。</li><li><strong>幻读（Phantom Read）</strong>：一个事务的两次查询中数据不一致。例如一个事务查询数据，而另一个事务却插入新的数据，先前事务的查询中，发现一些数据是之前查询中没有的<ul><li>参考阅读：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html" target="_blank" rel="noopener">MySQL Phantom Rows</a></li><li>幻读破坏了ACID中的隔离性：事务在执行过程中已读取数据不应该被改变</li></ul></li></ul><blockquote><p><strong>注意</strong>：根据<code>ANSI SQL Standard</code>在可重复读级别下允许出现幻读，MySQL实现满足标准，这不是Bug。但PostgreSQL在可重复读时不会出现幻读问题，这是不同引擎实现机制上的差异。<br>By default, InnoDB operates in REPEATABLE READ transaction isolation level. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 15.7.4, “Phantom Rows”). 缺省的，MySQL采用<code>REPEATABLE READ</code>事务隔离级别，采用<code>Next-key</code>锁机制来避免幻读问题</p></blockquote><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(Read Uncommitted)</td><td><strong>yes</strong></td><td>yes</td><td>yes</td></tr><tr><td>读已提交(Read Committed)</td><td>no</td><td><strong>yes</strong></td><td>yes</td></tr><tr><td>可重复读(Repeatable Read)</td><td>no</td><td>no</td><td><strong>yes</strong></td></tr><tr><td>可串行化(Searializable)</td><td>no</td><td>no</td><td>no</td></tr></tbody></table><blockquote><p>注意：MySQL采用<code>REPEATABLE READ</code>事务隔离级别，通过<code>Next-Key锁</code>来解决幻读问题</p></blockquote><h3 id="示例1：脏读"><a href="#示例1：脏读" class="headerlink" title="示例1：脏读"></a>示例1：脏读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">read</span> uncommitted; <span class="comment">-- 设置会话隔离级别为 未提交读</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx; <span class="comment">-- 此时为空，事务未提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xxx <span class="keyword">values</span>(<span class="number">1</span>); <span class="comment">-- 未提交事务中，插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xx; <span class="comment">-- 读取到会话2中未提交数据，这被称为 脏读</span></span><br></pre></td></tr></table></figure><p><code>脏读(Dirty Read)</code>是对一致性有要求的情况下无法接受的，所有<code>未提交读</code>在实际应用场景中几乎很少使用。</p><h3 id="示例2：不可重复读"><a href="#示例2：不可重复读" class="headerlink" title="示例2：不可重复读"></a>示例2：不可重复读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话1中操作：</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- 此时数据状态为a</span></span><br><span class="line"><span class="comment">-- 注意此会话中开启事务，未提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换至会话2操作</span></span><br><span class="line"><span class="keyword">update</span> xxx <span class="keyword">set</span> xxx=newValue <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- 更新数据至新的状态b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次切换至会话1操作</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 此时查询出的数据状态就有两种选择：新状态b、老状态a</span></span><br><span class="line"><span class="comment">-- 所谓的连续读：同一个事务中的两次读操作，数据状态保持一致</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>在<code>read committed</code>事务隔离级别下，切换会话1后读取到新的状态b，因为会话2中事务已提交。</li><li>在<code>repeatable read</code>事务隔离级别下，切换会话1后仍读取原始状态a，这就是所谓的【可重复读】</li></ul><table><thead><tr><th>操作顺序</th><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>1</td><td><code>start transaction;select * from xxx where id=1;</code></td><td></td></tr><tr><td>2</td><td></td><td><code>update xxx set xxx=newValue where id=1;</code></td></tr><tr><td>3</td><td><code>select * from xxx where id=1;</code></td><td></td></tr><tr><td>结果：<code>read committed</code>级别</td><td>newValue新状态数据（此时为<code>不可重复读</code>问题）</td><td></td></tr><tr><td>结果：<code>repeatable read</code>级别</td><td>原状态数据，满足<code>重复读</code>要求</td></tr></tbody></table><h3 id="示例3：幻读"><a href="#示例3：幻读" class="headerlink" title="示例3：幻读"></a>示例3：幻读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx;</span><br><span class="line"><span class="comment">-- 此时查询表为空，且事务未提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xxx <span class="keyword">values</span>(<span class="number">1</span>); <span class="comment">-- 新增一条记录</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx;</span><br><span class="line"><span class="comment">-- 此时查询表仍为空，表示满足[可重复读]特性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> xxx <span class="keyword">set</span> age=<span class="number">99</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- 更新会话2中插入记录(此时会话1并不可见)</span></span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="comment">-- 更新1条记录，隐约感觉不安</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx;</span><br><span class="line"><span class="comment">-- 再次读取时，竟然读取到内容(前一次读取时为空，2次读取时读取到内容)，出现`幻读`</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作顺序</th><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>1</td><td><code>start transaction;select * from xxx where id=1;</code>–空表</td><td></td></tr><tr><td>2</td><td></td><td><code>insert into xxx values(1);</code></td></tr><tr><td>3</td><td><code>select * from xxx;</code> – 新插入元素对会话1中查询不可见，满足<code>可重复读</code></td><td></td></tr><tr><td>4</td><td><code>update xxx set age=99 where id=1;select * from xxx;</code> – 新插入元素在会话1竟然可以被成功更新，<code>再次读时</code>读取到新内容，复现<code>幻读</code>问题</td><td></td></tr><tr><td>结果：<code>repeatable read</code>级别时</td><td>一个事务中，两次读操作，第二次读时发现了首次读时不存在的内容，这被称为<code>幻读</code>问题</td></tr></tbody></table><h2 id="附录：事务相关SQL命令"><a href="#附录：事务相关SQL命令" class="headerlink" title="附录：事务相关SQL命令"></a>附录：事务相关SQL命令</h2><blockquote><p>注：在MySQL 8.0中，事务相关变量名修改为<code>transaction_isolation</code></p></blockquote><ul><li><p>设置自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 取消autocommit</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"%autocommit%"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看隔离级别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @@global.tx_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @@session.tx_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line"><span class="comment">-- 三个角度的隔离：全局、会话、事务隔离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">"%iso%"</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%iso%'</span>;</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br></pre></td></tr></table></figure></li><li><p>设置事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure></li><li><p>事务操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务中一次读操作</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> text.tx;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 事务中回滚操作</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> text.tx;</span><br><span class="line"><span class="keyword">update</span> text.tx <span class="keyword">set</span> <span class="keyword">num</span> =<span class="number">10</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> text.tx(<span class="keyword">id</span>,<span class="keyword">num</span>) <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://stackoverflow.com/questions/36219508/read-committed-vs-repeatable-reads-in-mysql" target="_blank" rel="noopener">Read Committed Vs Repeatable Reads in MySQL?</a></li><li><a href="http://mysql.taobao.org/monthly/2017/06/07/" target="_blank" rel="noopener">淘宝：MySQL · 源码分析 · InnoDB Repeatable Read隔离级别之大不同</a></li><li><a href="https://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">MySQL 四种事务隔离级的说明-提供不可重复读、幻读的具体实例</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">MySQL InnoDB Locking</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;事务隔离是分布式系统对一致性保证的重要机制，是保证ACID的重要基础设施。&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL InnoDB事务隔离级别官方说明&lt;/a&gt;中对MySQL的事务隔离机制有详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post_images/transaction_isolation_levels.png&quot; alt=&quot;ANSI SQL STANDARD不同隔离级别对应问题&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合示例，本文对&lt;code&gt;事务隔离级别&lt;/code&gt;相关术语进行解析。&lt;br&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://fivezh.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis中内存淘汰算法实现</title>
    <link href="http://fivezh.github.io/2019/01/10/Redis-LRU-algorithm/"/>
    <id>http://fivezh.github.io/2019/01/10/Redis-LRU-algorithm/</id>
    <published>2019-01-10T06:41:21.000Z</published>
    <updated>2019-09-18T06:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的<code>maxmemory</code>支持的内存淘汰机制使得其成为一种有效的缓存方案，成为memcached的有效替代方案。</p><p>当内存达到<code>maxmemory</code>后，Redis会按照<code>maxmemory-policy</code>启动淘汰策略。<br><a id="more"></a></p><p>Redis 3.0中已有淘汰机制：</p><ul><li>noeviction</li><li>allkeys-lru</li><li>volatile-lru</li><li>allkeys-random</li><li>volatile-random</li><li>volatile-ttl</li></ul><table><thead><tr><th>maxmemory-policy</th><th>含义</th><th>特性</th></tr></thead><tbody><tr><td>noeviction</td><td>不淘汰</td><td>内存超限后写命令会返回错误(如OOM, del命令除外)</td><td></td></tr><tr><td>allkeys-lru</td><td>所有key的LRU机制</td><td>在所有key中按照最近最少使用LRU原则剔除key，释放空间</td><td></td></tr><tr><td>volatile-lru</td><td>易失key的LRU</td><td>仅以设置过期时间key范围内的LRU(如均为设置过期时间，则不会淘汰)</td><td></td></tr><tr><td>allkeys-random</td><td>所有key随机淘汰</td><td>一视同仁，随机</td><td></td></tr><tr><td>volatile-random</td><td>易失Key的随机</td><td>仅设置过期时间key范围内的随机</td><td></td></tr><tr><td>volatile-ttl</td><td>易失key的TTL淘汰</td><td>按最小TTL的key优先淘汰</td><td></td></tr></tbody></table><p>其中LRU(less recently used)经典淘汰算法在Redis实现中有一定优化设计，来保证内存占用与实际效果的平衡，这也体现了工程应用是空间与时间的平衡性。</p><blockquote><p>PS：值得注意的，在主从复制模式Replication下，从节点达到maxmemory时不会有任何异常日志信息，但现象为增量数据无法同步至从节点。</p></blockquote><h2 id="Redis-3-0中近似LRU算法"><a href="#Redis-3-0中近似LRU算法" class="headerlink" title="Redis 3.0中近似LRU算法"></a>Redis 3.0中近似LRU算法</h2><p>Redis中LRU是近似LRU实现，并不能取出理想LRU理论中最佳淘汰Key，而是通过从小部分采样后的样本中淘汰局部LRU键。</p><p>Redis 3.0中近似LRU算法通过增加待淘汰元素池的方式进一步优化，最终实现与精确LRU非常接近的表现。</p><blockquote><p>精确LRU会占用较大内存记录历史状态，而近似LRU则用较小内存支出实现近似效果。</p></blockquote><p>以下是理论LRU和近似LRU的效果对比：</p><p><img src="/assets/post_images/lru_comparison.png" alt="lru_comparison"></p><ul><li>按时间顺序接入不同键，此时最早写入也就是最佳淘汰键</li><li>浅灰色区域：被淘汰的键</li><li>灰色区域：未被淘汰的键</li><li>绿色区域：新增写入的键</li></ul><p>总结图中展示规律，</p><ul><li>图1<code>Theoretical LRU</code>符合预期：最早写入键逐步被淘汰</li><li>图2<code>Approx LRU Redis 3.0 10 samples</code>：Redis 3.0中近似LRU算法(采样值为10)</li><li>图3<code>Approx LRU Redis 2.8 5 samples</code>：Redis 2.8中近似LRU算法(采样值为5)</li><li>图4<code>Approx LRU Redis 3.0 5 samples</code>：Redis 3.0中近似LRU算法(采样值为5)</li></ul><p>结论：</p><ul><li>通过图4和图3对比：得出<strong>相同采样值下，3.0比2.8的LRU淘汰机制更接近理论LRU</strong></li><li>通过图4和图2对比：得出<strong>增加采样值，在3.0中将进一步改善LRU淘汰效果逼近理论LRU</strong></li><li>对比图2和图1：在3.0中采样值为10时，效果非常接近理论LRU</li></ul><p>采样值设置通过<code>maxmemory-samples</code>指定，可通过<code>CONFIG SET maxmemory-samples &lt;count&gt;</code>动态设置，也可启动配置中指定<code>maxmemory-samples &lt;count&gt;</code></p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||</span><br><span class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM)</span><br><span class="line">            &#123;......&#125;</span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">            &#123;......&#125;</span><br><span class="line">        <span class="comment">/* volatile-lru and allkeys-lru policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||</span><br><span class="line">            server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 淘汰池函数</span></span><br><span class="line">            evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</span><br><span class="line">                <span class="comment">// 从后向前逐一淘汰</span></span><br><span class="line">                <span class="keyword">for</span> (k = REDIS_EVICTION_POOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    de = dictFind(dict,pool[k].key); <span class="comment">// 定位目标</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    sdsfree(pool[k].key);</span><br><span class="line">                    <span class="comment">/* Shift all elements on its right to left. */</span></span><br><span class="line">                    memmove(pool+k,pool+k+<span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(REDIS_EVICTION_POOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                    <span class="comment">/* Clear the element on the right which is empty</span></span><br><span class="line"><span class="comment">                     * since we shifted one position to the left.  */</span></span><br><span class="line">                    pool[REDIS_EVICTION_POOL_SIZE<span class="number">-1</span>].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[REDIS_EVICTION_POOL_SIZE<span class="number">-1</span>].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de); <span class="comment">// 确定删除键</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... */</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* volatile-ttl */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == EDIS_MAXMEMORY_VOLATILE_TTL) &#123;......&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终选定待删除键bestkey</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslenbestkey)); <span class="comment">// 目标对象</span></span><br><span class="line">            propagateExpire(db,keyobj);</span><br><span class="line">            latencyStartMonitor(eviction_latency); <span class="comment">// 延迟监控开始</span></span><br><span class="line">            dbDelete(db,keyobj); <span class="comment">// 从db删除对象</span></span><br><span class="line">            latencyEndMonitor(eviction_latency);<span class="comment">// 延迟监控结束</span></span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,iction_latency); <span class="comment">// 延迟采样</span></span><br><span class="line">            latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta; <span class="comment">// 释放内存计数</span></span><br><span class="line">            server.stat_evictedkeys++; <span class="comment">// 淘汰key计数，info中可见</span></span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_EVICTED, <span class="string">"evicted"</span>, keyobj, db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">            decrRefCount(keyobj); <span class="comment">// 引用计数更新</span></span><br><span class="line">            keys_freed++;</span><br><span class="line">            <span class="comment">// 避免删除较多键导致的主从延迟，在循环内同步</span></span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-4-0中新的LFU算法"><a href="#Redis-4-0中新的LFU算法" class="headerlink" title="Redis 4.0中新的LFU算法"></a>Redis 4.0中新的LFU算法</h2><p>从Redis4.0开始，新增<a href="http://antirez.com/news/109" target="_blank" rel="noopener">LFU淘汰机制</a>，提供更好缓存命中率。LFU(Least Frequently Used)通过记录键使用频率来定位最可能淘汰的键。</p><p>对比LRU与LFU的差别：</p><ul><li>在LRU中，某个键很少被访问，但在刚刚被访问后其被淘汰概率很低，从而出现这类异常持续存在的缓存；相对的，其他可能被访问的键会被淘汰</li><li>而LFU中，按访问频次淘汰最少被访问的键</li></ul><p>Redis 4.0中新增两种LFU淘汰机制：</p><ul><li>volatile-lfu：设置过期时间的键按LFU淘汰</li><li>allkeys-lfu：所有键按LFU淘汰</li></ul><p>LFU使用<code>Morris counters</code>计数器占用少量位数来评估每个对象的访问频率，并随时间更新计数器。此机制实现与近似LRU中采样类似。但与LRU不同，LFU提供明确参数来指定计数更新频率。</p><ul><li>lfu-log-factor：0-255之间，饱和因子，值越小代表饱和速度越快</li><li>lfu-decay-time：衰减周期，单位分钟，计数器衰减的分钟数</li></ul><blockquote><p>The decay time is the obvious one, it is the amount of minutes a counter should be decayed, when sampled and found to be older than that value. A special value of 0 means: always decay the counter every time is scanned, and is rarely useful.<br>The counter logarithm factor changes how many hits are needed in order to saturate the frequency counter, which is just in the range 0-255. The higher the factor, the more accesses are needed in order to reach the maximum. The lower the factor, the better is the resolution of the counter for low accesses<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure></p></blockquote><p>这两个因子形成一种平衡，通过少量访问 VS 多次访问 的评价标准最终形成对键重要性的评判。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">Using Redis as an LRU cache</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis的&lt;code&gt;maxmemory&lt;/code&gt;支持的内存淘汰机制使得其成为一种有效的缓存方案，成为memcached的有效替代方案。&lt;/p&gt;
&lt;p&gt;当内存达到&lt;code&gt;maxmemory&lt;/code&gt;后，Redis会按照&lt;code&gt;maxmemory-policy&lt;/code&gt;启动淘汰策略。&lt;br&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://fivezh.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PHP7源码中的优雅设计</title>
    <link href="http://fivezh.github.io/2018/11/02/graceful-design-in-php7-src/"/>
    <id>http://fivezh.github.io/2018/11/02/graceful-design-in-php7-src/</id>
    <published>2018-11-02T12:06:33.000Z</published>
    <updated>2019-12-09T03:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>团队内分享PHP7源码，重读代码过程中发现其中不少优秀设计之处，整理一篇其源码中的优雅设计。<br><a id="more"></a></p><blockquote><p><strong>阅读要求</strong>：对PHP7源码实现有一定了解，具备一定的源码分析能力<br>推荐几篇优秀的文章，建议先行阅读：</p><ul><li>Array/HashTable实现，推荐阅读 <a href="http://blog.jpauli.tech/2016/04/08/hashtables.html" target="_blank" rel="noopener">Julien Pauli-PHP 7 Arrays : HashTables</a></li><li>鸟哥Laruence的slide：<a href="https://www.slideshare.net/laruence/the-secret-of-php7s-performance" target="_blank" rel="noopener">The secret of PHP7’s Performance</a></li></ul></blockquote><h2 id="Array如何保证有序"><a href="#Array如何保证有序" class="headerlink" title="Array如何保证有序"></a>Array如何保证有序</h2><p><strong>问题</strong>：在PHP中Array数组是通过HashTable哈希来实现，但由于Hash的特性是高效访问、但数据无序，因此面临数组遍历时顺序的问题？</p><h3 id="先来看看数组Array的实现"><a href="#先来看看数组Array的实现" class="headerlink" title="先来看看数组Array的实现"></a>先来看看数组Array的实现</h3><p>数组的两个重要结构体：</p><ul><li><code>Bucket</code>：单个元素的存储单元</li><li><code>_zend_array</code>别名<code>HashTable</code>：数组的上层封装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket &#123;</span><br><span class="line">zval              val;</span><br><span class="line">zend_ulong        h; /* hash value (or numeric index)   */</span><br><span class="line">zend_string      *key; /* string key or NULL for numerics */</span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_array HashTable;</span><br><span class="line"></span><br><span class="line">struct _zend_array &#123;</span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    flags,</span><br><span class="line">zend_uchar    nApplyCount,</span><br><span class="line">zend_uchar    nIteratorsCount,</span><br><span class="line">zend_uchar    reserve)</span><br><span class="line">&#125; v;</span><br><span class="line">uint32_t flags;</span><br><span class="line">&#125; u;</span><br><span class="line">uint32_t          nTableMask;</span><br><span class="line">Bucket           *arData;</span><br><span class="line">uint32_t          nNumUsed;</span><br><span class="line">uint32_t          nNumOfElements;</span><br><span class="line">uint32_t          nTableSize;</span><br><span class="line">uint32_t          nInternalPointer;</span><br><span class="line">zend_long         nNextFreeElement;</span><br><span class="line">dtor_func_t       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>老生常谈<code>_zend_array</code>：</p><ul><li><code>gc</code>：引用计数</li><li><code>u</code>：联合体<code>flags</code>或<code>v</code>标志位</li><li><code>nTableMask</code>：掩码, = -nTableSize</li><li><code>*arData</code>：指向数据元素存储Bucket地址</li><li><code>nNumUsed</code>：数组内已使用空间数量（unset元素后nNumUsed不变，nNumOfElements减少）</li><li><code>nNumOfElements</code>：数组内有效元素个数</li><li><code>nTableSize</code>：数组空间开辟大小</li><li><code>nInternalPointer</code>：待补充</li><li><code>nNextFreeElement</code>：下一个可用元素位置</li><li><code>pDestructor</code>：析构时处理</li></ul><h3 id="HashTable巧妙之处：nTableMask"><a href="#HashTable巧妙之处：nTableMask" class="headerlink" title="HashTable巧妙之处：nTableMask"></a>HashTable巧妙之处：<code>nTableMask</code></h3><ul><li><code>nTableMask = -nTableSize</code>：为什么同样一个<code>nTableSize</code>数值，额外用<code>nTableMask</code>冗余一份呢？<ul><li>通过位运算计算nIndex<code>nIndex = p-&gt;h | ht-&gt;nTableMask</code></li><li><code>h</code>是<code>key</code>进行hash计算后的哈希值，与<code>nTableMask</code>(补码表示，<code>nTableSize</code>反码+1)或运算，取值范围<code>[0, nTableSize-1]</code></li><li>实现效果与<code>nIndex = p-&gt;h % ht-&gt;nTableSize</code>相同，但<strong>位或运算效率比模运算高</strong>很多</li><li>空间 VS 时间 效率的博弈，这里冗余一个字段，大大提升频繁<code>nIndex</code>计算的效率</li></ul></li></ul><h3 id="HashTable巧妙之处：nNumUsed和nNumOfElemets"><a href="#HashTable巧妙之处：nNumUsed和nNumOfElemets" class="headerlink" title="HashTable巧妙之处：nNumUsed和nNumOfElemets"></a>HashTable巧妙之处：<code>nNumUsed</code>和<code>nNumOfElemets</code></h3><ul><li><code>nNumUsed</code>和<code>nNumOfElemets</code>为何区分开？<ul><li>释放中间元素时不做内存处理，保证高效，仅标记元素<code>p-&gt;val-&gt;u1.v.type=IS_UNDEF</code></li><li>在<code>resize()</code>或<code>rehash()</code>时将已删除的<code>IS_UNDEF</code>元素进行内存重整</li></ul></li></ul><h3 id="Array巧妙之处：arData、nIndex、idx"><a href="#Array巧妙之处：arData、nIndex、idx" class="headerlink" title="Array巧妙之处：arData、nIndex、idx"></a>Array巧妙之处：<code>arData</code>、<code>nIndex</code>、<code>idx</code></h3><ul><li>Array底层使用HashTable存储，如何保证插入数组元素的有序性？<ul><li>先重点看下arData指向的Bucket内部结构如下：<br><img src="/assets/post_images/hash_layout.png" alt="arData指向的Bucket内部结构图"></li><li>上图例子数据写入过程：<ul><li><code>nTableSize=8</code>，<code>nTableMask = -nTableSize = -8</code></li><li>数组首次写入元素<code>$array[&#39;bar] = &#39;bar-val&#39;</code>时，<code>h</code>为<code>bar</code>经过<code>Time33</code>算法计算后的数值，<code>nIndex = h | nTableMask = -3</code></li><li><code>idx=nNumUsed++</code>、<code>arData[nIdex] = idx</code>，从而写入映射表<code>arData[-3] = 0</code>，数据写入<code>arData[idx]=Bucket{key,h,val}</code>也就是<code>arData[0]={&#39;bar&#39;,hash(bar),&#39;bar-var&#39;}</code></li><li>相同的，插入<code>$array[&#39;foo&#39;] = 42</code>时，写入映射表<code>arData[-5]=1</code>，数据写入<code>arData[idx]=Bucket{key,h,val}</code>也就是<code>arData[1]={&#39;foo&#39;,hash(foo),42}</code></li><li><img src="/assets/post_images/addToHash.png" alt="/Zend/zend_hash.c:605"></li></ul></li><li><code>arData</code>指向区域包含两部分：<code>hash映射表</code>和<code>数据存储Buckets</code>，后者Buckets为数据存储区。如直接hash取模的方式存储(散列值跳跃且分散)，则遍历时无法保证顺序，因此衍生出通过<code>hash映射表</code>来实现的方式</li><li><code>arData</code>指向Buckets存储区的起始位置，而<code>hash映射表</code>在其负值索引位置上，nIndex为负值，通过数组的负值索引快速访问<code>arData[nIndex]</code>值</li><li>具体来说，根据<code>nNumUsed</code>确定首个可用Buckets索引地址idx，继而计算nIndex(<code>nIndex = h | nTableMask</code>)，将数据在Buckets区的存储索引idx保存到映射表：<code>arData[nIndex] = idx</code></li><li>索引查找时，按照<code>h-&gt;nIndex-&gt;idx</code>的顺序查找数据，几乎是O(1)复杂度的</li><li>顺序遍历时，按照Buckets区逐一遍历即使插入时顺序</li><li><strong>巧妙的</strong>，这里将映射表和数据区连续内存空间存储，且nIndex通过<code>h|nTableMask</code>的方式快速计算获得，极大保证计算效率；连续分配，释放、扩容时都是简单高效的处理方式</li></ul></li></ul><p>最终数组的存储结构：(图片来源鸟哥分享slide)<br><img src="/assets/post_images/phpZendArray.png" alt="php7-zend-array"></p><h2 id="zend-string中变长数组"><a href="#zend-string中变长数组" class="headerlink" title="zend_string中变长数组"></a>zend_string中变长数组</h2><p><code>zend_string</code>结构体定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_string &#123;</span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">zend_ulong        h; /* hash value */</span><br><span class="line">size_t            len;</span><br><span class="line">char              val[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><code>gc</code>：引用计数</li><li><code>h</code>：字符串对应的hash值</li><li><code>len</code>：字符串长度</li><li><code>val[1]</code>：变长数组，实际字符串存储区域</li></ul><h3 id="zend-string巧妙之处：val-1"><a href="#zend-string巧妙之处：val-1" class="headerlink" title="zend_string巧妙之处：val[1]"></a><code>zend_string</code>巧妙之处：<code>val[1]</code></h3><ul><li>变长数组(<a href="https://en.wikipedia.org/wiki/Variable-length_array" target="_blank" rel="noopener">Variable-length array</a>)是在<a href="https://en.wikipedia.org/wiki/C99" target="_blank" rel="noopener">ISO C99</a>之后才支持的特性，使用此特性需要编译器支持C99标准。</li><li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Zero-Length.html#Zero-Length" target="_blank" rel="noopener">零长数组</a>是GNU C版本编译器支持，并引导C99最终支持变长数组的经典案例，但不同版本实现的编译器可能<a href="https://coolshell.cn/articles/11377.html" target="_blank" rel="noopener">不支持零长数组</a>。</li><li>在PHP7源码中为了兼容不同版本编译器、利用变长数组特性，使用<code>val[1]</code>来实现<code>固定头部的可变对象</code>的存储形式。</li></ul><p>后续补充：<br>巧妙之处：<code>IS_UNDEF</code><br>TODO：删除时设置为<code>IS_UNDEF</code>，在需要时统一进行内存整理提高单次操作性能。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://maxielj.github.io/2018/08/20/php%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">团队建哥-PHP7数组实现</a></li><li><a href="http://blog.jpauli.tech/2016/04/08/hashtables.html" target="_blank" rel="noopener">PHP 7 Arrays : HashTables</a></li><li><a href="http://joshuais.me/yi-php7-shu-zu-hashtable/" target="_blank" rel="noopener">PHP 7 Arrays : HashTables中文译文</a></li><li><a href="http://www.laruence.com/2018/04/08/3170.html" target="_blank" rel="noopener">深入理解PHP7内核之zval</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;团队内分享PHP7源码，重读代码过程中发现其中不少优秀设计之处，整理一篇其源码中的优雅设计。&lt;br&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="http://fivezh.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Composer创建待发布代码库</title>
    <link href="http://fivezh.github.io/2018/07/12/ComposerBuildPackage/"/>
    <id>http://fivezh.github.io/2018/07/12/ComposerBuildPackage/</id>
    <published>2018-07-12T09:04:51.000Z</published>
    <updated>2019-09-18T06:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>现代PHP发展过程中，最初原始的文件拷贝、代码Ctrl+C/V的分发模式，phpear分发模式，再发展到composer横空出世，现代PHP库依赖管理通过composer解决各类库的版本依赖管理。</p><p>下文介绍如何打包发布自己的代码库：<br><a id="more"></a></p><h2 id="新建待发布代码包"><a href="#新建待发布代码包" class="headerlink" title="新建待发布代码包"></a>新建待发布代码包</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ul><li><code>composer init</code></li><li>修改后的composer.json文件如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"fivezh/utils"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"utils"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"library"</span>,</span><br><span class="line">    <span class="attr">"authors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"fivezh"</span>,</span><br><span class="line">            <span class="attr">"email"</span>: <span class="string">"fivezh@gmail.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"guzzlehttp/guzzle"</span>: <span class="string">"~6.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PSR-4配置"><a href="#PSR-4配置" class="headerlink" title="PSR-4配置"></a>PSR-4配置</h3><ul><li>新增目录src/Rrc/Hello.php</li><li><code>composer.json</code>增加psr-4的autoload</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"autoload" :&#123;</span><br><span class="line">  "psr-4":&#123;</span><br><span class="line">    "Rrc\\":"src/Rrc"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新命名空间"><a href="#更新命名空间" class="headerlink" title="更新命名空间"></a>更新命名空间</h3><ul><li>执行<code>composer dump-autoload</code>更新autoload文件，将更新<code>vendor/composer/autoload_psr4.php</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'Rrc\\'</span> =&gt; <span class="keyword">array</span>($vendorDir . <span class="string">'/rrc/c2bUtils/src/Rrc'</span>),</span><br><span class="line">    <span class="string">'Psr\\Http\\Message\\'</span> =&gt; <span class="keyword">array</span>($vendorDir . <span class="string">'/psr/http-message/src'</span>),</span><br><span class="line">    <span class="string">'GuzzleHttp\\Psr7\\'</span> =&gt; <span class="keyword">array</span>($vendorDir . <span class="string">'/guzzlehttp/psr7/src'</span>),</span><br><span class="line">    <span class="string">'GuzzleHttp\\Promise\\'</span> =&gt; <span class="keyword">array</span>($vendorDir . <span class="string">'/guzzlehttp/promises/src'</span>),</span><br><span class="line">    <span class="string">'GuzzleHttp\\'</span> =&gt; <span class="keyword">array</span>($vendorDir . <span class="string">'/guzzlehttp/guzzle/src'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="编写TestCase"><a href="#编写TestCase" class="headerlink" title="编写TestCase"></a>编写TestCase</h3><ul><li>增加phpunit包</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"require-dev": &#123;</span><br><span class="line">    "phpunit/phpunit": "^6.2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增加phpunit.xml</li></ul><p>设置bootstarp加载<code>vendor/autoload.php</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">phpunit</span> <span class="attr">backupGlobals</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">backupStaticAttributes</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">bootstrap</span>=<span class="string">"vendor/autoload.php"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">colors</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertErrorsToExceptions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertNoticesToExceptions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertWarningsToExceptions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">processIsolation</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">stopOnFailure</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">syntaxCheck</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testsuites</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">"Application Test Suite"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>./tests<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testsuites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">php</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">"TEST_CASE"</span> <span class="attr">value</span>=<span class="string">"testing"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">php</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">phpunit</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写testcase测试用例</li></ul><p>新建文件<code>test\DingMsg</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Rrc</span>\<span class="title">DingMsg</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DingMsgTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPushSingleMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $alarm = <span class="keyword">new</span> DingMsg();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $res = $alarm-&gt;pushGroupRobotMsg(<span class="string">'invalid_access_token'</span>,</span><br><span class="line">                <span class="string">'hello world'</span>, [<span class="string">'18612345678'</span>], <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;assertEquals(<span class="keyword">false</span>, $res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (\<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;fail(<span class="string">'异常：'</span>.$e-&gt;getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行<code>phpunit</code>则运行tests/下全部测试用例</p><p>至此，完整的<code>composer.json</code>文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"rrc/c2bUtils"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"c2b utils"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"library"</span>,</span><br><span class="line">    <span class="attr">"authors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"zhangxiaowu"</span>,</span><br><span class="line">            <span class="attr">"email"</span>: <span class="string">"zhangxiaowu@renrenche.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"guzzlehttp/guzzle"</span>: <span class="string">"~6.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"require-dev"</span>: &#123;</span><br><span class="line">        <span class="attr">"phpunit/phpunit"</span>: <span class="string">"^6.2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"autoload"</span> :&#123;</span><br><span class="line">      <span class="attr">"psr-4"</span>:&#123;</span><br><span class="line">        <span class="attr">"Rrc\\"</span>:<span class="string">"src/Rrc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布到svc仓库或packagelist"><a href="#发布到svc仓库或packagelist" class="headerlink" title="发布到svc仓库或packagelist"></a>发布到svc仓库或packagelist</h2><h3 id="上传代码库至私有仓库或github"><a href="#上传代码库至私有仓库或github" class="headerlink" title="上传代码库至私有仓库或github"></a>上传代码库至私有仓库或github</h3><p>一般企业内部私有仓库，则将代码推送至私有仓库远程分支</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:yourusername/yourlibraryname.git</span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">"initial files"</span></span><br><span class="line">git tag -a v1<span class="number">.0</span><span class="number">.0</span> -m <span class="string">"initial release"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="发布至packagelist"><a href="#发布至packagelist" class="headerlink" title="发布至packagelist"></a>发布至packagelist</h3><p>访问<a href="https://packagist.org/packages/submit" target="_blank" rel="noopener">packagelist/package/submit</a>，注册、登录、提交Github地址则会被packagelist收录。</p><p>详细参考：<a href="https://juejin.im/entry/57d7c3d2a0bb9f0057f244fc" target="_blank" rel="noopener">如何创建一个自己的 Composer 库</a></p><h2 id="新项目通过composer引用代码库"><a href="#新项目通过composer引用代码库" class="headerlink" title="新项目通过composer引用代码库"></a>新项目通过<code>composer</code>引用代码库</h2><h3 id="vsc托管方式"><a href="#vsc托管方式" class="headerlink" title="vsc托管方式"></a>vsc托管方式</h3><p>如果代码库是内部托管（git/svn/hg等），可通过repositories形式引入包。</p><ol><li>修改新项目的composer.json，增加依赖库引入</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"repositories"</span>: &#123;</span><br><span class="line">  <span class="string">"c2bUtils"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"vcs"</span>,</span><br><span class="line">    <span class="string">"url"</span>:<span class="string">"git@gitlab.renrenche.com:zhangxiaowu/c2b_php_utils.git"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="string">"require"</span>: &#123;</span><br><span class="line">  <span class="string">"rrc/c2bUtils"</span>: <span class="string">"^1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>repositories</code>中的url仅仅是仓库的地址和包名无关</li><li><code>require</code>中为包名，即库项目的<code>composer.json</code>中的<code>name</code>项</li></ul><ol start="2"><li>执行<code>composer install -vvv</code>安装依赖库</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; composer install -v</span><br><span class="line">Loading composer repositories with <span class="keyword">package</span> information                                                                                                      Updating dependencies (including require-dev)         </span><br><span class="line">Dependency resolution completed in <span class="number">0.001</span> seconds</span><br><span class="line">Analyzed <span class="number">237</span> packages to resolve dependencies</span><br><span class="line">Analyzed <span class="number">303</span> rules to resolve dependencies</span><br><span class="line">Package operations: <span class="number">5</span> installs, <span class="number">0</span> updates, <span class="number">0</span> removals</span><br><span class="line">Installs: guzzlehttp/promises:v1<span class="number">.3</span><span class="number">.1</span>, psr/http-message:<span class="number">1.0</span><span class="number">.1</span>, guzzlehttp/psr7:<span class="number">1.4</span><span class="number">.2</span>, guzzlehttp/guzzle:<span class="number">6.3</span><span class="number">.3</span>, rrc/c2bUtils:<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  - Installing guzzlehttp/promises (v1<span class="number">.3</span><span class="number">.1</span>) Loading from cache Extracting archive</span><br><span class="line">  - Installing psr/http-message (<span class="number">1.0</span><span class="number">.1</span>) Loading from cache Extracting archive</span><br><span class="line">  - Installing guzzlehttp/psr7 (<span class="number">1.4</span><span class="number">.2</span>) Loading from cache Extracting archive</span><br><span class="line">  - Installing guzzlehttp/guzzle (<span class="number">6.3</span><span class="number">.3</span>) Loading from cache Extracting archive</span><br><span class="line">  - Installing rrc/c2butils (<span class="number">1.0</span><span class="number">.0</span>) Cloning <span class="number">1</span>ccfd6bcfd95cd3b1ea884594c9f58f8fe7283fd</span><br><span class="line">guzzlehttp/guzzle suggests installing psr/log (Required <span class="keyword">for</span> using the Log middleware)</span><br><span class="line">Writing lock file</span><br><span class="line">Generating autoload files</span><br></pre></td></tr></table></figure><p>此时如果查看<code>vendor/composer/autoload_psr4.php</code>，应该可以看到新增包的PSR-4映射已经加入到此文件中。</p><h3 id="packagelist方式"><a href="#packagelist方式" class="headerlink" title="packagelist方式"></a>packagelist方式</h3><p>如果代码库已提交至packagelist.org，则已被composer可检索。<br>就如同使用guzzlehttp/guzzle包一样，直接通过<code>composer require apptut/web-util -vvv</code>引入进来即可。</p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><h4 id="通过composer-require进来后，autoload无法找到对应命名空间"><a href="#通过composer-require进来后，autoload无法找到对应命名空间" class="headerlink" title="通过composer require进来后，autoload无法找到对应命名空间"></a>通过<code>composer require</code>进来后，autoload无法找到对应命名空间</h4><p>这个问题出发点在于，未对repositories中的type正确设置：</p><ul><li>composer：composer类型的库</li><li>vsc：从git/svn/hg获取</li><li>pear：从pear获取资源</li><li>package：未提供composer支持，需手动进行autoload设置</li></ul><p>如果自有代码仓库，且包含composer.json支持，则配置repositories时指定类型为vsc，可自动加载依赖项目的autoload；<br>如果自有代码仓库，无composer.json支持，说明是静态冷文件，无法自动加载，需要引入代码仓库后，手动进行autoload的设置，classmap/psr-4/files等各种形式都可以。</p><h3 id="通过repositories安装库时无法找到"><a href="#通过repositories安装库时无法找到" class="headerlink" title="通过repositories安装库时无法找到"></a>通过repositories安装库时无法找到</h3><ul><li><code>composer install</code>错误信息如下<code>he requested package could not be found in any version, there may be a typo in the package name.</code></li><li>可能的问题：<ul><li>包名错误</li><li>未找到满足要求的代码库版本</li></ul></li><li>解决：composer依赖tag信息选择版本，代码库必须有对应tag信息</li><li><code>git tag -a v1.0.0 -m &quot;initial release&quot;</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Your requirements could not be resolved to an installable set of packages.</span><br><span class="line"></span><br><span class="line">  Problem <span class="number">1</span></span><br><span class="line">    - The requested <span class="keyword">package</span> rrc/c2b_utils could not be found in any version, there may be a typo in the <span class="keyword">package</span> name.</span><br><span class="line"></span><br><span class="line">Potential causes:</span><br><span class="line"> - A typo in the <span class="keyword">package</span> name</span><br><span class="line"> - The <span class="keyword">package</span> is not available in a stable-enough version according to your minimum-stability setting</span><br><span class="line">   see &lt;https:<span class="comment">//getcomposer.org/doc/04-schema.md#minimum-stability&gt; for more details.</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.phpcomposer.com/04-schema.html#repositories" target="_blank" rel="noopener">Composer repositories</a></li><li><a href="http://www.darwinbiler.com/creating-composer-package-library/" target="_blank" rel="noopener">Creating Composer Package Library</a></li><li><a href="https://juejin.im/entry/57d7c3d2a0bb9f0057f244fc" target="_blank" rel="noopener">如何创建一个自己的 Composer 库</a></li><li><a href="https://zhuanlan.zhihu.com/p/27943241" target="_blank" rel="noopener">基于 Composer 的 PHP 模块化开发</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现代PHP发展过程中，最初原始的文件拷贝、代码Ctrl+C/V的分发模式，phpear分发模式，再发展到composer横空出世，现代PHP库依赖管理通过composer解决各类库的版本依赖管理。&lt;/p&gt;
&lt;p&gt;下文介绍如何打包发布自己的代码库：&lt;br&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="http://fivezh.github.io/tags/PHP/"/>
    
    <category term="Composer" scheme="http://fivezh.github.io/tags/Composer/"/>
    
  </entry>
  
</feed>
